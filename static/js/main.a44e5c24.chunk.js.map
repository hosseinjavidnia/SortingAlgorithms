{"version":3,"sources":["visualizer/algorithm/sortingalgorithms/heapSort.js","component/header/SectionHeader.js","team/image/how-it-works-image.jpg","component/IsVisibleYDirection/IsVisibleYDirection.js","howitworks/step/Step.js","howitworks/StepsData.js","howitworks/HowItWorks.js","visualizer/sortingvisualizer/component/legend/LegendInformation.js","visualizer/sortingvisualizer/component/legend/LegendHeader.js","visualizer/sortingvisualizer/util/GeneralUtil.js","visualizer/sortingvisualizer/component/legend/Legend.js","visualizer/sortingvisualizer/util/MathUtil.js","visualizer/sortingvisualizer/util/CountingSortUtil.js","visualizer/sortingvisualizer/util/RadixSortUtil.js","visualizer/sortingvisualizer/util/MergeSortUtil.js","visualizer/algorithm/sortingalgorithms/swap.js","visualizer/sortingvisualizer/util/SwappingAlgoUtil.js","visualizer/sortingvisualizer/util/BucketSortUtil.js","visualizer/algorithm/sortingalgorithms/insertionSort.js","visualizer/algorithm/sortingalgorithms/quickSort.js","visualizer/algorithm/sortingalgorithms/bubbleSort.js","visualizer/algorithm/sortingalgorithms/bucketSort.js","visualizer/algorithm/sortingalgorithms/mergeSort.js","visualizer/algorithm/sortingalgorithms/allSorts.js","visualizer/algorithm/sortingalgorithms/radixSort.js","visualizer/algorithm/sortingalgorithms/countingSort.js","visualizer/algorithm/sortingalgorithms/selectionSort.js","visualizer/algorithm/sortingalgorithms/shellSort.js","visualizer/sortingvisualizer/util/ArrayUtil.js","visualizer/sortingvisualizer/component/selectors/algorithmselector/AlgorithmSelector.js","visualizer/sortingvisualizer/component/selectors/sliderselector/SliderSelector.js","visualizer/sortingvisualizer/util/QuickSortUtil.js","visualizer/sortingvisualizer/component/selectors/sliderselector/SelectorProps.js","visualizer/sortingvisualizer/component/animationprogressbar/AnimationProgressBar.js","visualizer/sortingvisualizer/component/block/CountingSortBlock.js","visualizer/sortingvisualizer/component/multipleblocks/HorizontalArray.js","visualizer/sortingvisualizer/component/block/CountBlock.js","visualizer/sortingvisualizer/component/animationscreen/CountingSortScreen.js","visualizer/sortingvisualizer/component/block/HighlightUtil.js","visualizer/sortingvisualizer/component/block/HighlightedOval.js","visualizer/sortingvisualizer/component/multipleblocks/StackOfBoxes.js","visualizer/sortingvisualizer/component/animationscreen/RadixSortScreen.js","visualizer/sortingvisualizer/component/block/BucketSortBlock.js","visualizer/sortingvisualizer/component/multipleblocks/StackOfAnimatedBoxes.js","visualizer/sortingvisualizer/component/block/Oval.js","visualizer/sortingvisualizer/component/animationscreen/BucketSortScreen.js","visualizer/sortingvisualizer/component/block/MergeSortBlock.js","visualizer/sortingvisualizer/component/animationscreen/AnimationScreenUtil.js","visualizer/sortingvisualizer/component/animationscreen/MergeSortScreen.js","visualizer/sortingvisualizer/component/block/AnimatedBlock.js","visualizer/sortingvisualizer/component/animationscreen/GenericSortScreen.js","visualizer/sortingvisualizer/component/animationscreen/AnimationScreen.js","visualizer/algorithm/stepbysteptemplate/genericSwapStepByStep.js","visualizer/algorithm/stepbysteptemplate/radixSortStepByStep.js","visualizer/algorithm/stepbysteptemplate/allSortsStepByStep.js","visualizer/algorithm/stepbysteptemplate/selectionSortStepByStep.js","visualizer/algorithm/stepbysteptemplate/mergeSortStepByStep.js","visualizer/algorithm/stepbysteptemplate/quickSortStepByStep.js","visualizer/algorithm/stepbysteptemplate/countingSortStepByStep.js","visualizer/algorithm/stepbysteptemplate/bucketSortStepByStep.js","visualizer/algorithm/stepbysteptemplate/heapSortStepByStep.js","visualizer/sortingvisualizer/component/stepbystep/StepByStepUtil.js","visualizer/sortingvisualizer/component/stepbystep/StepByStep.js","visualizer/sortingvisualizer/component/button/forwardbackbutton/BackButton.js","visualizer/sortingvisualizer/component/button/threestatebutton/PlayPauseReplayButton.js","visualizer/sortingvisualizer/component/button/threestatebutton/ThreeStateButton.js","visualizer/sortingvisualizer/component/button/newdatabutton/NewDataButton.js","visualizer/sortingvisualizer/component/button/forwardbackbutton/ForwardButton.js","visualizer/sortingvisualizer/component/button/ButtonBox.js","visualizer/codeinformation/explanations/Explanations.js","visualizer/codeinformation/explanations/bubbleSortEx.js","visualizer/codeinformation/explanations/insertionSortEx.js","visualizer/codeinformation/explanations/quickSortEx.js","visualizer/codeinformation/explanations/radixSortEx.js","visualizer/codeinformation/explanations/bucketSortEx.js","visualizer/codeinformation/explanations/countingSortEx.js","visualizer/codeinformation/explanations/selectionSortEx.js","visualizer/codeinformation/explanations/mergeSortEx.js","visualizer/codeinformation/explanations/shellSortEx.js","visualizer/codeinformation/explanations/heapSortEx.js","visualizer/codeinformation/codeexplaination/PerformanceSection.js","visualizer/codeinformation/codeexplaination/CodeExplanation.js","visualizer/codeinformation/templates/Templates.js","visualizer/codeinformation/templates/bubbleSortTemplate.js","visualizer/codeinformation/templates/insertionSortTemplate.js","visualizer/codeinformation/templates/quickSortTemplate.js","visualizer/codeinformation/templates/radixSortTemplate.js","visualizer/codeinformation/templates/bucketSortTemplate.js","visualizer/codeinformation/templates/countingSortTemplate.js","visualizer/codeinformation/templates/selectionSortTemplate.js","visualizer/codeinformation/templates/mergeSortTemplate.js","visualizer/codeinformation/templates/shellSortTemplate.js","visualizer/codeinformation/templates/heapSortTemplate.js","visualizer/codeinformation/codetemplate/Selector.js","visualizer/codeinformation/codetemplate/CodeTemplate.js","visualizer/codeinformation/CodeInformation.js","visualizer/sortingvisualizer/Visualizer.js","app/App.js","reportWebVitals.js","index.js"],"names":["array_length","SectionHeader","sectionHeader","translateX","HeaderStyling","isVisible","transform","transition","HeaderLineStyling","nodeRef","useRef","once","className","ref","style","IsVisibleYDirection","props","transitionStyling","yValue","classNameToUse","children","Step","icon","title","description","StepsData","size","color","HowItWorks","id","src","HowItWorksImage","alt","map","data","index","LegendInformation","backgroundImage","LegendHeader","isCountingSort","visualizerAlgorithm","isRadixSort","isBucketSort","isRadixOrBucket","isMergeSort","isSelectionSort","isQuickSort","hasLegend","Legend","useContext","VisualizerStateContext","legendInformation","generateValue","min","max","Math","floor","random","roundToTwoDp","num","round","buckets","height","count","executeCountSort","currentAnimation","referenceArray","animationPx","countArr","isForward","isShown","stack","value","array","generateRandomValue","randomVal","executeRadixSort","stackArr","isDistributing","location","push","unshift","shift","pop","findIndexToUseInMergeSort","newTempArr","iIdx","jIdx","k","length","isUsingIIdx","prevPos","isUsingJIdx","handleMergeSort","width","arrayCopy","isShift","kIdx","isReset","allIndexToShift","idxToUse","positiveDiff","abs","xDirection","pos","i","swap","j","arr","temp","executeSwap","firstIdx","secondIdx","isSwapOccurring","resetArray","isSwap","highlight","executeGenericSort","setReferenceArray","arrToUse","innerSortUsed","executeBucketSort","executeInnerBucketSort","undefined","isSort","executeResetBucket","insertionSort","receivedArr","animationArr","key","quickSortHelper","low","high","pi","pivot","partition","quickSort","bubbleSort","flag","bucketSort","Array","item","insertionSortAnimation","concat","mergeSortHelper","start","end","mid","n1","n2","leftArray","rightArray","allIndexInSwap","merge","heap_root","left","right","SortingAlgorithms","inputArr","maxNum","x","divisor","apply","smallestIdx","n","gap","tempArrElement","JSON","parse","stringify","arrayGenerator","generateDefaultArray","generateMergeSortArray","generateCountSortArray","generateRadixSortArray","toFixed","generateBucketSortArray","generateArray","AlgorithmChooser","dataSize","setDataSize","isPlay","isInMidstOfSort","setIsReplay","setIsInMidstOfSort","setVisualizerAlgorithm","setArrayData","setAnimationPercentage","setIsReset","setCountArr","setStackArr","setHistoryArr","useState","algorithm","setAlgorithm","menu","algorithmName","Item","onClick","handleMenuClick","cursor","overlay","trigger","placement","disabled","e","preventDefault","DownOutlined","SliderSelector","setData","name","maxSize","sliderData","setSliderData","defaultValue","onChange","val","executeQuickSort","pivotIdx","executeSwapWithPivot","SpeedSelectorProps","DataSizeSelectorProps","AnimationProgressBar","animationPercentage","status","strokeColor","percent","CountingSortBlock","visibility","HorizontalArray","BlockType","CountBlock","backgroundColor","CountingSortScreen","marginTop","highlightDigit","idx","currentHighlighted","getDigitToHighlight","current","numberMapping","fontWeight","spreadNumber","from","toString","HighlightedOval","display","StackOfBoxes","individualStack","RadixSortScreen","justifyContent","minHeight","BucketSortBlock","y","rest","div","interpolate","StackOfAnimatedBoxes","yDirection","useTransition","d","opacity","leave","enter","update","Oval","BucketSortScreen","MergeSortBlock","zIndex","translateXOfVisualizer","MergeSortScreen","transitions","AnimatedBlock","GenericSortScreen","AnimationScreen","isReplay","arrayData","speed","setIdx","executeForwardAnimation","resetDataWhenAnimationFinish","animationSpeedArray","setIsPlay","useEffect","setTimeout","dataItem","parseInt","genericSwapStepByStep","animationArrSwapIdx","firstIdxVal","secondIdxVal","isBigger","message","radixSortStepByStep","SortingAlgorithmsStepByStep","isSmaller","values","slice","comparisonStatement","swapStatement","pivotIdxVal","command","indexOfSmallerElement","incJ","incI","heapStep","getStepByStepText","sortAlgoStepByStep","StepByStep","BackButton","executeBackwardAnimation","isEmpty","Provider","PlayPauseReplayButton","type","ThreeStateButton","NewDataButton","ForwardButton","isFull","ButtonBox","explanations","additionalDesc","worstTime","averageTime","bestTime","worstSpace","stable","inPlace","link","PerformanceSection","sortDetails","ListOfComplexities","Complexity","TypeWithIcon","isTick","IconType","CodeExplanation","algo","setSortDetails","HeaderOne","Explanation","HeaderTwo","templates","Java","JavaScript","Python","Selector","selected","setSelected","Select","language","background","CodeTemplate","template","setTemplate","mode","toLowerCase","theme","fontSize","editorProps","$blockScrolling","readOnly","CodeInformation","React","createContext","Visualizer","setSpeed","setAnimationArr","historyArr","sortAlgo","getAnimationArr","nextReferenceArray","executeMergeSortForward","executeMergeSortBackward","finalReferenceArray","AlgorithmSelector","changeDataSize","App","Date","getFullYear","href","target","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","console","log"],"mappings":"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","file":"static/js/main.a44e5c24.chunk.js","sourcesContent":["/**\n * Sorts the array using Heap Sort and stores each sorting step into the animation array.\n *\n * @memberOf SortingAlgorithms\n * @see {@link https://www.w3resource.com/javascript-exercises/searching-and-sorting-algorithm/searching-and-sorting-algorithm-exercise-3.php}\n * @param {Object[]} arr The array to be sorted.\n * @returns {any[]} Animation array which contains the animation instruction for each step.\n */\nimport { swap } from './swap';\n\n// Keeps track of how many items are not sorted\nlet array_length;\n\n// Keeps track of the animation\nlet animationArr = [];\n\n// Bubbling the element up to its correct position (heapify)\nconst heap_root = (arr, i) => {\n  let left = 2 * i + 1;\n  let right = 2 * i + 2;\n  let max = i;\n\n  if (left < array_length && arr[left].height > arr[max].height) {\n    max = left;\n  }\n\n  if (right < array_length && arr[right].height > arr[max].height) {\n    max = right;\n  }\n\n  animationArr.push([i, max, false, false]);\n\n  if (max !== i) {\n    animationArr.push([i, max, true, false]);\n\n    swap(i, max, arr);\n    heap_root(arr, max);\n  }\n};\n\nconst heapSort = (arr) => {\n  let receivedArr = arr;\n  array_length = receivedArr.length;\n  animationArr = [];\n\n  // Creating the maximum heap\n  for (let i = Math.floor(array_length / 2); i >= 0; i -= 1) {\n    heap_root(receivedArr, i);\n  }\n\n  // Sorting the array by extracting the the element and placing at the end of the array\n  for (let i = arr.length - 1; i > 0; i--) {\n    animationArr.push([i, 0, true, true]);\n    swap(0, i, receivedArr);\n    array_length--;\n\n    heap_root(receivedArr, 0);\n  }\n\n  return animationArr;\n};\n\nexport default heapSort;\n","import React, { useRef } from 'react';\nimport './styles.css';\nimport 'intersection-observer';\nimport IsVisible from 'react-is-visible';\n\n/**\n * General component header that animates to the center upon entering user's view port.\n *\n * @component\n * @param {string} sectionHeader Name of the section header.\n * @param {string} translateX Extra translation in x direction for the line underneath the header.\n * @returns {JSX.Element} Header for each category.\n */\nconst SectionHeader = ({ sectionHeader, translateX }) => {\n  /**\n   * Animates the header to the center.\n   *\n   * @param isVisible boolean value denoting whether the component is visible in user's view port.\n   * @returns {{transform: string, transition: string}} Inline-styling for animation.\n   */\n  const HeaderStyling = (isVisible) => ({\n    transform: isVisible ? `translateX(0px)` : `translateX(750px)`,\n    transition: `all 1.5s ease-in-out`,\n  });\n  const HeaderLineStyling = (isVisible) => ({\n    transform: isVisible ? translateX : `translateX(-750px)`,\n    transition: `all 1.5s ease-in-out`,\n  });\n\n  const nodeRef = useRef();\n\n  return (\n    <IsVisible once>\n      {(isVisible) => (\n        <div className=\"section-header\" ref={nodeRef}>\n          <span style={HeaderStyling(isVisible)}>{sectionHeader}</span>\n          <div className=\"section-header-line\" style={HeaderLineStyling(isVisible)} />\n        </div>\n      )}\n    </IsVisible>\n  );\n};\n\nexport default SectionHeader;\n","export default __webpack_public_path__ + \"static/media/how-it-works-image.48b6ebba.jpg\";","import React from 'react';\nimport IsVisible from 'react-is-visible';\n\n/**\n * A wrapper component which helps to animate the component upwards.\n *\n * @component\n * @param {any} props Attribute to be passed into this component.\n */\nconst IsVisibleYDirection = (props) => {\n  const transitionStyling = (isVisible) => ({\n    transform: isVisible ? `translateY(0px)` : props.yValue,\n    transition: `all 1.0s ease-in-out`,\n  });\n\n  return (\n    <IsVisible once>\n      {(isVisible) => (\n        <div className={props.classNameToUse} style={transitionStyling(isVisible)}>\n          {props.children}\n        </div>\n      )}\n    </IsVisible>\n  );\n};\n\nexport default IsVisibleYDirection;\n","import React from 'react';\nimport './styles.css';\nimport IsVisibleYDirection from '../../component/IsVisibleYDirection/IsVisibleYDirection';\n\n/**\n * General instruction step in How It Works Section.\n *\n * @component\n * @param {icon} icon Icon of the step.\n * @param {string} title Title of the step.\n * @param {string} description Description of the step.\n * @returns {JSX.Element} A complete step component.\n */\nconst Step = ({ icon, title, description }) => {\n  return (\n    <IsVisibleYDirection classNameToUse=\"step-container\" yValue={`translateY(125px)`}>\n      <div className=\"step-picture\">{icon}</div>\n      <p className=\"step-title\">{title}</p>\n      <p className=\"step-description\">{description}</p>\n    </IsVisibleYDirection>\n  );\n};\n\nexport default Step;\n","import { AiFillSetting, AiOutlineSelect } from 'react-icons/ai';\nimport { GoPlay } from 'react-icons/go';\nimport { MdReplay } from 'react-icons/md';\nimport React from 'react';\n\n/**\n * Array containing the details of each particular step.\n */\nexport const StepsData = [\n  {\n    icon: <AiOutlineSelect size={70} color={'#11C2C9'} />,\n    title: '1. Select the Algorithm',\n    description: 'Visualize the algorithm of your choice.',\n  },\n  {\n    icon: <AiFillSetting size={70} color={'#5466FF'} />,\n    title: '2. Select Settings',\n    description: 'Adjust the speed of the visualizer and array size.',\n  },\n  {\n    icon: <GoPlay size={70} color={'#5466FF'} />,\n    title: '3. Start Sorting',\n    description: 'Press the play button to start the step by step sorting process.',\n  },\n  {\n    icon: <MdReplay size={70} color={'#11C2C9'} />,\n    title: '4. Fast-forward, Backtrack, and Replay',\n    description:\n      'Replay the entire sorting process or walk through ' +\n      'the algorithm one step at a time with these functions.',\n  },\n];\n","import React from 'react';\n\nimport './styles.css';\n\nimport HowItWorksHeader from '../component/header/SectionHeader';\nimport HowItWorksImage from '../team/image/how-it-works-image.jpg';\nimport Step from './step/Step';\nimport { StepsData } from './StepsData';\n\n/**\n * How It Works Section of the app.\n *\n * @component\n * @category App Body\n */\nconst HowItWorks = () => {\n  return (\n    <div id=\"howItWorks\" className=\"how-it-works\">\n      <HowItWorksHeader sectionHeader={'How it Works'} translateX={'translateX(28px)'} />\n      <div className=\"how-it-works-container\">\n        <img className=\"how-it-works-picture\" src={HowItWorksImage} alt=\"\" />\n        <div className=\"steps\">\n          {/*Steps 1 and 3*/}\n          {StepsData.map((data, index) =>\n            index % 2 === 0 ? (\n              <Step icon={data.icon} title={data.title} description={data.description} />\n            ) : null\n          )}\n        </div>\n        <div className=\"steps\">\n          {/*Steps 2 and 4*/}\n          {StepsData.map((data, index) =>\n            index % 2 === 1 ? (\n              <Step icon={data.icon} title={data.title} description={data.description} />\n            ) : null\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default HowItWorks;\n","import React from 'react';\nimport './styles.css';\n\n/**\n * The information which is displayed in the legend component.\n *\n * @component\n * @category Legend\n */\nconst LegendInformation = ({ color, description }) => {\n  return (\n    <div className=\"legend-information\">\n      <div className=\"legend-information-box-holder\">\n        <div className=\"legend-information-box-box\" style={{ backgroundImage: color }} />\n      </div>\n      <div className=\"legend-information-description-holder\">\n        <span className=\"legend-information-description-text\">{description}</span>\n      </div>\n    </div>\n  );\n};\n\nexport default LegendInformation;\n","import React from 'react';\nimport './styles.css';\n\n/**\n * Header for the Legend.\n *\n * @component\n * @category Legend\n */\nconst LegendHeader = () => {\n  return (\n    <>\n      <div className=\"legend-header\">\n        <span>Legend</span>\n      </div>\n      <div className=\"legend-header-line\" />\n    </>\n  );\n};\n\nexport default LegendHeader;\n","/**\n * Returns true if the algorithm input is counting sort.\n *\n * @method\n * @category GeneralUtil\n * @param {string} visualizerAlgorithm Input algorithm.\n * @returns {boolean} True if the algorithm is counting sort.\n */\nexport const isCountingSort = (visualizerAlgorithm) => visualizerAlgorithm === 'Counting Sort';\n\n/**\n * Returns true if the algorithm input is radix sort.\n *\n * @method\n * @category GeneralUtil\n * @param {string} visualizerAlgorithm Input algorithm.\n * @returns {boolean} True if the algorithm is radix sort.\n */\nexport const isRadixSort = (visualizerAlgorithm) => visualizerAlgorithm === 'Radix Sort';\n\n/**\n * Returns true if the algorithm input is bucket sort.\n *\n * @method\n * @category GeneralUtil\n * @param {string} visualizerAlgorithm Input algorithm.\n * @returns {boolean} True if the algorithm is bucket sort.\n */\nexport const isBucketSort = (visualizerAlgorithm) => visualizerAlgorithm === 'Bucket Sort';\n\n/**\n * Returns true if the algorithm input is radix or bucket sort.\n *\n * @method\n * @category GeneralUtil\n * @param {string} visualizerAlgorithm Input algorithm.\n * @returns {boolean} True if the algorithm is radix or bucket sort.\n */\nexport const isRadixOrBucket = (visualizerAlgorithm) =>\n  isRadixSort(visualizerAlgorithm) || isBucketSort(visualizerAlgorithm);\n\n/**\n * Returns true if the algorithm input is merge sort.\n *\n * @method\n * @category GeneralUtil\n * @param {string} visualizerAlgorithm Input algorithm.\n * @returns {boolean} True if the algorithm is merge sort.\n */\nexport const isMergeSort = (visualizerAlgorithm) => visualizerAlgorithm === 'Merge Sort';\n\n/**\n * Returns true if the algorithm input is selection sort.\n *\n * @method\n * @category GeneralUtil\n * @param {string} visualizerAlgorithm Input algorithm.\n * @returns {boolean} True if the algorithm is selection sort.\n */\nexport const isSelectionSort = (visualizerAlgorithm) => visualizerAlgorithm === 'Selection Sort';\n\n/**\n * Returns true if the algorithm input is quick sort.\n *\n * @method\n * @category GeneralUtil\n * @param {string} visualizerAlgorithm Input algorithm.\n * @returns {boolean} True if the algorithm is quick sort.\n */\nexport const isQuickSort = (visualizerAlgorithm) => visualizerAlgorithm === 'Quick Sort';\n\n/**\n * Returns true if the algorithm input is any sort aside from bucket, radix and counting sort.\n *\n * @method\n * @category GeneralUtil\n * @param {string} visualizerAlgorithm Input algorithm.\n * @returns {boolean} True if the algorithm is any sort aside from bucket, radix and counting sort.\n */\nexport const hasLegend = (visualizerAlgorithm) =>\n  visualizerAlgorithm === 'Bubble Sort' ||\n  visualizerAlgorithm === 'Insertion Sort' ||\n  visualizerAlgorithm === 'Selection Sort' ||\n  visualizerAlgorithm === 'Quick Sort' ||\n  visualizerAlgorithm === 'Heap Sort' ||\n  visualizerAlgorithm === 'Merge Sort' ||\n  visualizerAlgorithm === 'Shell Sort';\n","import React, { useContext } from 'react';\nimport LegendInformation from './LegendInformation';\nimport LegendHeader from './LegendHeader';\nimport './styles.css';\nimport { VisualizerStateContext } from '../../Visualizer';\nimport { hasLegend, isMergeSort, isSelectionSort } from '../../util/GeneralUtil';\n\n/**\n * A legend which display information about the current sorting animation.\n *\n * @component\n * @category Visualizer\n */\nconst Legend = () => {\n  const { visualizerAlgorithm } = useContext(VisualizerStateContext);\n\n  const legendInformation = [\n    {\n      color: 'linear-gradient(45deg, #13B1B7, #11C2C9)',\n      description: isMergeSort(visualizerAlgorithm)\n        ? 'Currently involved in the merge process'\n        : isSelectionSort(visualizerAlgorithm)\n        ? 'Currently involved in selection process'\n        : 'Currently involved in the swap process',\n    },\n    {\n      color: 'linear-gradient(45deg, #287ED0, #5466FF)',\n      description: isMergeSort(visualizerAlgorithm)\n        ? 'Not involved in the merge process'\n        : isSelectionSort(visualizerAlgorithm)\n        ? 'Not involved in the selection process'\n        : 'Not involved in the swap process',\n    },\n  ];\n\n  return (\n    <div className=\"legend-box\">\n      {hasLegend(visualizerAlgorithm) && (\n        <div>\n          <div className=\"legend-header-box\">\n            <LegendHeader />\n          </div>\n          <div className=\"legend-information-box\">\n            {legendInformation.map(({ color, description }, index) => (\n              <LegendInformation color={color} description={description} key={index} />\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Legend;\n","/**\n * Generates a random number within [min, max].\n *\n * @method\n * @category MathUtil\n * @param {number} min Min number selected.\n * @param {number} max Max number selected.\n * @returns {number} Random number generated.\n */\nexport const generateValue = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\n/**\n * Rounds the number to 2 decimal places, if necessary.\n *\n * @method\n * @category MathUtil\n * @see {@link https://stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-only-if-necessary|Stack Overflow}\n * @param {number} num Input number.\n * @returns {number} Rounded number with maximum 2 decimal places.\n */\nexport const roundToTwoDp = (num) => {\n  return +(Math.round(num + 'e+2') + 'e-2');\n};\n","import { generateValue } from './MathUtil';\n\n/**\n * Buckets used for counting sort animation.\n *\n * @category CountingSortUtil\n * @const {Object[]}\n */\nexport const buckets = [\n  { height: 1, count: 0 },\n  { height: 2, count: 0 },\n  { height: 3, count: 0 },\n  { height: 4, count: 0 },\n  { height: 5, count: 0 },\n  { height: 6, count: 0 },\n  { height: 7, count: 0 },\n  { height: 8, count: 0 },\n  { height: 9, count: 0 },\n];\n\n/**\n * Generates the random array for counting sort.\n *\n * @method\n * @category CountingSortUtil\n * @param {number} size Size of array generated.\n * @returns {Object[]} Random array for counting sort.\n */\nexport const generateCountSortArray = (size) => {\n  let array = [];\n  for (let i = 0; i < size; i++) {\n    array.push({\n      id: i,\n      height: generateValue(1, 9),\n      isShown: true,\n    });\n  }\n  return array;\n};\n\n// Function to execute the counting sort animation\n\n/**\n * Executes one step of the counting sort algorithm.\n *\n * @method\n * @category CountingSortUtil\n * @param {Object} currentAnimation Current animation object.\n * @param {Object[]} referenceArray Current state of the data array in the sorting execution.\n * @param {number} animationPx Current animation percentage.\n * @param {Object[]} countArr Count bucket array used for counting sort.\n * @param {boolean} isForward Boolean value which states if this is a forward or backward animation.\n * @returns {Object[]} The next state of the reference array after this sorting step.\n */\nexport const executeCountSort = (\n  currentAnimation,\n  referenceArray,\n  animationPx,\n  countArr,\n  isForward\n) => {\n  if (typeof currentAnimation !== 'undefined') {\n    const index = currentAnimation.id;\n    const height = currentAnimation.height;\n    const isCountAnimation = (isForward && animationPx <= 50) || (!isForward && animationPx >= 50);\n    if (isCountAnimation) {\n      referenceArray[index].isShown = false;\n      countArr[height - 1].count += 1;\n    } else {\n      referenceArray[index] = currentAnimation;\n      referenceArray[index].isShown = true;\n      countArr[height - 1].count -= 1;\n    }\n    return referenceArray;\n}\nelse {\n  return 0;\n}\n};\n","import { generateValue } from './MathUtil';\n\n/**\n * Fixed stack array created for radix and bucket sort usage.\n *\n * @category RadixSortUtil\n * @const {Object[]}\n */\nexport const stack = [\n  { value: 0, array: [] },\n  { value: 1, array: [] },\n  { value: 2, array: [] },\n  { value: 3, array: [] },\n  { value: 4, array: [] },\n  { value: 5, array: [] },\n  { value: 6, array: [] },\n  { value: 7, array: [] },\n  { value: 8, array: [] },\n  { value: 9, array: [] },\n];\n\n/**\n * Generates a random value for generation of array in radix sort.\n *\n * @method\n * @category RadixSortUtil\n * @returns {number} Random number generated.\n */\nexport const generateRandomValue = () => {\n  const randomVal = Math.random();\n  if (randomVal < 0.1) {\n    return generateValue(1, 9);\n  } else if (randomVal < 0.2) {\n    return generateValue(10, 99);\n  } else if (randomVal <= 1) {\n    return generateValue(100, 999);\n  }\n};\n\n/**\n * Generates the random array for radix sort.\n *\n * @method\n * @category RadixSortUtil\n * @param {number} size Size of array generated.\n * @returns {Object[]} Random array for radix sort.\n */\nexport const generateRadixSortArray = (size) => {\n  let array = [];\n  for (let i = 0; i < size; i++) {\n    array.push({\n      id: i,\n      height: generateRandomValue(),\n      isShown: true,\n    });\n  }\n  return array;\n};\n\n/**\n * Executes one step of the radix sort algorithm.\n *\n * @method\n * @category RadixSortUtil\n * @param {Object} currentAnimation Current animation object.\n * @param {Object[]} referenceArray Current state of the data array in the sorting execution.\n * @param {Object[]} stackArr Current state of the stack array in the sorting execution.\n * @param {boolean} isForward Boolean value which states if this is a forward or backward animation.\n * @returns {Object[]} The next state of the reference array after this sorting step.\n */\nexport const executeRadixSort = (currentAnimation, referenceArray, stackArr, isForward) => {\n  if (typeof currentAnimation !== 'undefined') {\n    const index = currentAnimation.id;\n    const isDistributing = currentAnimation.isDistributing;\n    const isDistributingAnimation = !(isForward ^ isDistributing);\n\n    if (isDistributingAnimation) {\n      referenceArray[index].isShown = false;\n      const location = currentAnimation.location;\n      if (isForward) {\n        stackArr[location].array.push(currentAnimation);\n      } else {\n        stackArr[location].array.unshift(currentAnimation);\n      }\n    } else {\n      // Putting back into array\n      const location = currentAnimation.location;\n      referenceArray[index] = currentAnimation;\n      referenceArray[index].isShown = true;\n      if (isForward) {\n        stackArr[location].array.shift();\n      } else {\n        stackArr[location].array.pop();\n      }\n    }\n    return referenceArray;\n}\nelse {\n  return 0;\n}\n};\n","import { generateValue } from './MathUtil';\nimport { arrayCopy } from './ArrayUtil';\n\n/**\n * This is to find the \"correct\" index to be swapped since the actual array is not being swapped.\n *\n * @method\n * @category MergeSortUtil\n * @param {Object[]} newTempArr The new input array.\n * @param {number} iIdx I-th Index to be swapped.\n * @param {number} jIdx J-th Index to be swapped.\n * @returns {number} The index to be used in the swap animation.\n */\nexport const findIndexToUseInMergeSort = (newTempArr, iIdx, jIdx) => {\n  for (let k = 0; k < newTempArr.length; k++) {\n    let isUsingIIdx = iIdx === -1 && newTempArr[k].prevPos === jIdx;\n    let isUsingJIdx = jIdx === -1 && newTempArr[k].prevPos === iIdx;\n    if (isUsingIIdx || isUsingJIdx) {\n      return k;\n    }\n  }\n  return -1;\n};\n\n/**\n * A sorting execution for Merge Sort.\n *\n * @method\n * @category MergeSortUtil\n * @param {any[]} currentAnimation The current animation to be executed.\n * @param {Object[]} referenceArray The array holding data for the \"blocks\".\n * @param {Object[]} historyArr An array holding the data of each states of the reference array.\n * @param {function} setReferenceArray A set state method for reference array.\n * @returns {Object[]} The resultant array upon the swap animation.\n */\nexport const executeMergeSortForward = (\n  currentAnimation,\n  referenceArray,\n  historyArr,\n  setReferenceArray\n) => {\n  let nextReferenceArray = handleMergeSort(referenceArray, currentAnimation);\n  historyArr.push(referenceArray);\n  setReferenceArray(nextReferenceArray);\n  return nextReferenceArray;\n};\n\n/**\n * A sorting execution for Merge Sort in the reverse direction.\n *\n * @method\n * @category MergeSortUtil\n * @param {Object[]} historyArr An array holding the data of each states of the reference array.\n * @param {function} setReferenceArray A set state method for reference array.\n */\nexport const executeMergeSortBackward = (historyArr, setReferenceArray) => {\n  setReferenceArray(historyArr.pop());\n};\n\n/**\n * A \"hackish\" method to simulate the swapping in merge swap without actually sorting the array.\n *\n * @method\n * @category MergeSortUtil\n * @param {Object[]} referenceArray The array holding data for the \"blocks\".\n * @param {any[]} currentAnimation The current animation to be executed.\n * @returns {Object[]} The resultant array upon the swap animation\\.\n */\nexport const handleMergeSort = (referenceArray, currentAnimation) => {\n  let dataSize = referenceArray.length;\n  let width = 800 / dataSize;\n  let newTempArr = arrayCopy(referenceArray);\n\n  if (typeof currentAnimation !== 'undefined') {\n    let isShift = currentAnimation[2];\n    let iIdx = currentAnimation[0];\n    let jIdx = currentAnimation[1];\n    let kIdx = currentAnimation[3];\n    let isReset = currentAnimation[4];\n    // is Shift true represents moving down, false means moving back up to the desired position.\n    if (isShift) {\n      let allIndexToShift = currentAnimation[5];\n      for (let value of allIndexToShift) {\n        // hard code one of the index to be -1\n        let idxToUse = findIndexToUseInMergeSort(newTempArr, value, -1);\n        newTempArr[idxToUse].isShift = true;\n      }\n    } else {\n      let idxToUse = findIndexToUseInMergeSort(newTempArr, iIdx, jIdx);\n      let positiveDiff = Math.abs(kIdx - idxToUse);\n      newTempArr[idxToUse].xDirection =\n        kIdx - idxToUse <= 0\n          ? -(positiveDiff * width) + (kIdx - 0) * 10\n          : positiveDiff * width + (kIdx - 0) * 10;\n      newTempArr[idxToUse].isShift = false;\n      newTempArr[idxToUse].pos = kIdx;\n      if (isReset) {\n        // this signifies the end of \"1 iteration of combining together\"\n        for (let i = 0; i < newTempArr.length; i++) {\n          newTempArr[i].prevPos = newTempArr[i].pos;\n        }\n      }\n    }\n    return newTempArr;\n}\nelse {\n  return referenceArray;\n}\n};\n\n/**\n * Generates the random data for merge sort.\n *\n * @method\n * @category MergeSortUtil\n * @param {number} size The number of blocks to be shown.\n * @returns {Object[]} A array containing the states of each block.\n */\nexport const generateMergeSortArray = (size) => {\n  let array = [];\n  for (let i = 0; i < size; i++) {\n    array.push({\n      xDirection: i * 10,\n      pos: i,\n      prevPos: i,\n      height: generateValue(1, 9),\n      isShift: false,\n      id: i,\n    });\n  }\n  return array;\n};\n","export const swap = (i, j, arr) => {\n  let temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n};\n","// For swapping algorithms\nimport { swap } from '../../algorithm/sortingalgorithms/swap';\nimport { resetArray } from './ArrayUtil';\n\n/**\n * Sets the state of the \"block\" or \"oval\" to be highlighted.\n *\n * @method\n * @category SwappingUtil\n * @param {number} firstIdx The first block\" or \"oval\" to be highlighted.\n * @param {number} secondIdx The second block\" or \"oval\" to be highlighted.\n * @param {Object[]} arr The array which the index at {@code firstIdx} and {@code secondIdx} is highlighted\n */\nexport const highlight = (firstIdx, secondIdx, arr) => {\n  arr[firstIdx].isSwap = true;\n  arr[secondIdx].isSwap = true;\n};\n\n/**\n * Swaps the position of the two object in the array.\n *\n * @method\n * @category SwappingUtil\n * @param {number} firstIdx The first index to be swapped in the array.\n * @param {number} secondIdx The second index to be swapped in the array.\n * @param {Object[]} arr The array which the index at {@code firstIdx} and {@code secondIdx} is swapped and highlighted or just highlighted.\n * @param {boolean} isSwapOccurring A boolean value denoting whether a swap will occur.\n * @param {string} visualizerAlgorithm The current algorithm of the visualizer.\n * @returns {Object[]} A new Object array which has been been swap and highlighted or just highlighted.\n */\nexport const executeSwap = (firstIdx, secondIdx, arr, isSwapOccurring, visualizerAlgorithm) => {\n  let newTempArr = resetArray(visualizerAlgorithm, arr);\n  highlight(firstIdx, secondIdx, newTempArr);\n  if (!isSwapOccurring) {\n    return newTempArr;\n  }\n  swap(firstIdx, secondIdx, newTempArr);\n  return newTempArr;\n};\n\n/**\n * A generic sorting execution for Insertion, Bubble, Selection, Shell Sort\n *\n * @method\n * @category SwappingUtil\n * @param {any[]} currentAnimation The current animation to be executed.\n * @param {Object[]} referenceArray The array holding data for the \"blocks\"\n * @param {string} visualizerAlgorithm The current algorithm of the visualizer\n * @param {function} setReferenceArray A set state method for reference array.\n * @returns {Object[]} The resultant array upon the swap animation\n */\nexport const executeGenericSort = (\n  currentAnimation,\n  referenceArray,\n  visualizerAlgorithm,\n  setReferenceArray\n) => {\n  if (typeof currentAnimation !== 'undefined') {\n    let firstIdx = currentAnimation[0];\n    let secondIdx = currentAnimation[1];\n    let isSwapOccurring = currentAnimation[2];\n    let arrToUse = executeSwap(\n      firstIdx,\n      secondIdx,\n      referenceArray,\n      isSwapOccurring,\n      visualizerAlgorithm\n    );\n    setReferenceArray(arrToUse);\n    return arrToUse;\n  }\n  else {\n    return 0;\n  }\n};\n","import { executeRadixSort } from './RadixSortUtil';\nimport { executeSwap } from './SwappingAlgoUtil';\nimport { resetArray } from './ArrayUtil';\n\n/**\n * Generates a random decimal.\n *\n * @category BucketSortUtil\n * @returns {number} Random decimal generated.\n */\nconst generateDecimal = () => {\n  return +Math.random().toFixed(3);\n};\n\n/**\n * Inner sorting algorithm used for bucket sort.\n *\n * @category BucketSortUtil\n * @type {string}\n */\nconst innerSortUsed = 'Insertion Sort';\n\n/**\n * Executes one step of the bucket sort algorithm.\n *\n * @method\n * @category BucketSortUtil\n * @param {any} currentAnimation Current animation object.\n * @param {Object[]} referenceArray Current state of the data array in the sorting execution.\n * @param {Object[]} stackArr Current state of the stack array in the sorting execution.\n * @param {boolean} isForward Boolean value which states if this is a forward or backward animation.\n * @returns {Object[]} The next state of the reference array after this sorting step.\n */\nexport const executeBucketSort = (currentAnimation, referenceArray, stackArr, isForward) => {\n  if (typeof currentAnimation !== 'undefined') {\n    if (currentAnimation.length === 4) {\n      executeInnerBucketSort(currentAnimation, stackArr);\n    } else if (currentAnimation.isSort === undefined) {\n      executeRadixSort(currentAnimation, referenceArray, stackArr, isForward);\n    } else {\n      executeResetBucket(currentAnimation, stackArr);\n    }\n    return referenceArray;\n}\nelse {\n  return 0;\n}\n};\n\n/**\n * Executes one step of insertion sort on one single bucket.\n *\n * @category BucketSortUtil\n * @param {any[]} currentAnimation Current animation object.\n * @param {Object[]} stackArr Current stack array.\n */\nconst executeInnerBucketSort = (currentAnimation, stackArr) => {\n  const firstIdx = currentAnimation[0];\n  const secondIdx = currentAnimation[1];\n  const isSwapOccurring = currentAnimation[2];\n  const location = currentAnimation[3];\n  stackArr[location].array = executeSwap(\n    firstIdx,\n    secondIdx,\n    stackArr[location].array,\n    isSwapOccurring,\n    innerSortUsed\n  );\n};\n\n/**\n * Resets the inner bucket to the default state. This removes any leftover highlight from the\n * elements.\n *\n * @category BucketSortUtil\n * @param {Object} currentAnimation Current animation object.\n * @param {Object[]} stackArr Current stack array.\n */\nconst executeResetBucket = (currentAnimation, stackArr) => {\n  const location = currentAnimation.location;\n  stackArr[location].array = resetArray(innerSortUsed, stackArr[location].array);\n};\n\n/**\n * Generates the random array for bucket sort.\n *\n * @method\n * @category BucketSortUtil\n * @param {number} size Size of array generated.\n * @returns {Object[]} Random array for bucket sort.\n */\nexport const generateBucketSortArray = (size) => {\n  let array = [];\n  for (let i = 0; i < size; i++) {\n    array.push({\n      id: i,\n      height: generateDecimal(),\n      isShown: true,\n    });\n  }\n  return array;\n};\n","/**\n * Sorts the array using Insertion Sort and stores each sorting step into the animation array.\n *\n * @memberOf SortingAlgorithms\n * @param {Object[]} arr The array to be sorted.\n * @returns {any[]} Animation array which contains the animation instruction for each step.\n */\nconst insertionSort = (arr) => {\n  let receivedArr = arr;\n  let animationArr = [];\n  let length = receivedArr.length;\n  for (let i = 1; i < length; i++) {\n    let key = receivedArr[i];\n    let j = i - 1;\n    animationArr.push([i, i - 1, false]);\n    while (j >= 0 && receivedArr[j].height > key.height) {\n      receivedArr[j + 1] = receivedArr[j];\n      animationArr.push([j + 1, j, true]);\n      j--;\n      if (j >= 0 && receivedArr[j].height > key.height) {\n        animationArr.push([j + 1, j, false]);\n      }\n    }\n    receivedArr[j + 1] = key;\n  }\n  return animationArr;\n};\n\nexport default insertionSort;\n","import { swap } from './swap';\n\nconst partition = (arr, low, high, animationArr) => {\n  let pivot = arr[high].height;\n  let i = low - 1;\n  for (let j = low; j < high; j++) {\n    if (arr[j].height < pivot) {\n      // first boolean is to represent a swap\n      animationArr.push([j, j, false, high, 'incI', i]);\n      i++;\n      if (i !== j) {\n        animationArr.push([i, j, true, high, 'iToJ', i]);\n        swap(i, j, arr);\n      }\n    } else {\n      animationArr.push([j, j, false, high, 'jToPivot', i]);\n    }\n  }\n  animationArr.push([i + 1, high, true, high, 'swapPivot', i]);\n  swap(i + 1, high, arr);\n  return i + 1;\n};\n\nconst quickSortHelper = (arr, low, high, animationArr) => {\n  if (low < high) {\n    let pi = partition(arr, low, high, animationArr);\n    quickSortHelper(arr, low, pi - 1, animationArr);\n    quickSortHelper(arr, pi + 1, high, animationArr);\n  }\n};\n\n/**\n * Sorts the array using Quick Sort and stores each sorting step into the animation array.\n *\n * @memberOf SortingAlgorithms\n * @see {@link https://www.geeksforgeeks.org/quick-sort/}\n * @param {Object[]} arr The array to be sorted.\n * @returns {any[]} Animation array which contains the animation instruction for each step.\n */\nconst quickSort = (arr) => {\n  let animationArr = [];\n  quickSortHelper(arr, 0, arr.length - 1, animationArr);\n  return animationArr;\n};\n\nexport default quickSort;\n","import { swap } from './swap';\n\n/**\n * Sorts the array using Bubble Sort and stores each sorting step into the animation array.\n *\n * @memberOf SortingAlgorithms\n * @param {Object[]} arr The array to be sorted.\n * @returns {any[]} Animation array which contains the animation instruction for each step.\n */\nconst bubbleSort = (arr) => {\n  let receivedArr = arr;\n  let animationArr = [];\n  for (let i = receivedArr.length - 1; i >= 0; i--) {\n    let flag = true;\n    for (let j = 0; j < i; j++) {\n      animationArr.push([j + 1, j, false]);\n      if (receivedArr[j].height > receivedArr[j + 1].height) {\n        swap(j, j + 1, receivedArr);\n        animationArr.push([j + 1, j, true]);\n        flag = false;\n      }\n    }\n    if (flag) {\n      break;\n    }\n  }\n  return animationArr;\n};\n\nexport default bubbleSort;\n","import insertionSort from './insertionSort';\n\n/**\n * Sorts the array using Bucket Sort and stores each sorting step into the animation array.\n *\n * @memberOf SortingAlgorithms\n * @param {Object[]} arr The array to be sorted.\n * @returns {any[]} Animation array which contains the animation instruction for each step.\n */\nconst bucketSort = (arr) => {\n  const totalSlots = 10;\n  let buckets = [...Array(totalSlots)].map(() => []);\n  let animationArr = [];\n  let id = 0;\n  for (const item of arr) {\n    const location = Math.floor(totalSlots * item.height);\n    animationArr.push({\n      id: id,\n      height: item.height,\n      isShown: true,\n      location: location,\n      isDistributing: true,\n    });\n    id++;\n    buckets[location].push(item);\n  }\n\n  // Sort all arrays in buckets\n  for (let i = 0; i < totalSlots; i++) {\n    // Signify start of sort\n    animationArr.push({\n      isSort: true,\n      location: i,\n    });\n\n    // Execute insertion sort animations\n    let insertionSortAnimation = insertionSort(buckets[i]).map((arr) => [...arr, i]);\n    animationArr = animationArr.concat(insertionSortAnimation);\n\n    // Signify end of sort\n    animationArr.push({\n      isSort: false,\n      location: i,\n    });\n  }\n\n  // Restore element back into array\n  id = 0;\n  let location = 0;\n  for (const array of buckets) {\n    for (const item of array) {\n      animationArr.push({\n        id: id,\n        height: item.height,\n        isShown: true,\n        location: location,\n        isDistributing: false,\n        isSwap: false,\n      });\n      id++;\n    }\n    location++;\n  }\n  return animationArr;\n};\n\nexport default bucketSort;\n","const merge = (receivedArr, start, mid, end, animationArr) => {\n  const n1 = mid - start + 1;\n  const n2 = end - mid;\n  let leftArray = [];\n  let rightArray = [];\n  let allIndexInSwap = [];\n  for (let i = 0; i < n1; i++) {\n    leftArray.push(receivedArr[start + i]);\n    allIndexInSwap.push(start + i);\n  }\n  for (let j = 0; j < n2; j++) {\n    rightArray.push(receivedArr[mid + 1 + j]);\n    allIndexInSwap.push(mid + 1 + j);\n  }\n  animationArr.push([-1, -1, true, -1, false, allIndexInSwap]);\n  let i = 0,\n    j = 0,\n    k = start;\n  while (i < n1 && j < n2) {\n    if (leftArray[i].height <= rightArray[j].height) {\n      animationArr.push([start + i, -1, false, k, false]);\n      receivedArr[k++] = leftArray[i++];\n    } else {\n      animationArr.push([-1, mid + 1 + j, false, k, false]);\n      receivedArr[k++] = rightArray[j++];\n    }\n  }\n\n  while (i < n1) {\n    if (i + 1 === n1) {\n      animationArr.push([start + i, -1, false, k, true]);\n    } else {\n      animationArr.push([start + i, -1, false, k, false]);\n    }\n    receivedArr[k++] = leftArray[i++];\n  }\n\n  while (j < n2) {\n    if (j + 1 === n2) {\n      animationArr.push([-1, mid + 1 + j, false, k, true]);\n    } else {\n      animationArr.push([-1, mid + 1 + j, false, k, false]);\n    }\n    receivedArr[k++] = rightArray[j++];\n  }\n};\n\nconst mergeSortHelper = (receivedArr, animationArr, start, end) => {\n  if (start < end) {\n    const mid = Math.floor((start + end) / 2);\n    mergeSortHelper(receivedArr, animationArr, start, mid);\n    mergeSortHelper(receivedArr, animationArr, mid + 1, end);\n    merge(receivedArr, start, mid, end, animationArr);\n  }\n};\n\n/**\n * Sorts the array using Merge Sort and stores each sorting step into the animation array.\n *\n * @memberOf SortingAlgorithms\n * @see {@link https://www.geeksforgeeks.org/merge-sort/}\n * @param {Object[]} arr The array to be sorted.\n * @returns {any[]} Animation array which contains the animation instruction for each step.\n */\nconst mergeSort = (arr) => {\n  let receivedArr = arr;\n  let animationArr = [];\n  mergeSortHelper(receivedArr, animationArr, 0, arr.length - 1);\n  return animationArr;\n};\n\nexport default mergeSort;\n","import insertionSort from './insertionSort';\nimport quickSort from './quickSort';\nimport bubbleSort from './bubbleSort';\nimport radixSort from './radixSort';\nimport bucketSort from './bucketSort';\nimport countingSort from './countingSort';\nimport mergeSort from './mergeSort';\nimport selectionSort from './selectionSort';\nimport shellSort from './shellSort';\nimport heapSort from './heapSort';\n\n/**\n * An Object component that is used to access the sorting method.\n *\n * @namespace SortingAlgorithms\n * @type {Object}\n */\nconst SortingAlgorithms = {\n  'Insertion Sort': insertionSort,\n  'Bubble Sort': bubbleSort,\n  'Quick Sort': quickSort,\n  'Radix Sort': radixSort,\n  'Bucket Sort': bucketSort,\n  'Counting Sort': countingSort,\n  'Selection Sort': selectionSort,\n  'Merge Sort': mergeSort,\n  'Shell Sort': shellSort,\n  'Heap Sort': heapSort,\n};\n\nexport default SortingAlgorithms;\n","/**\n * Sorts the array using Radix Sort and stores each sorting step into the animation array.\n *\n * @memberOf SortingAlgorithms\n * @see {@link https://www.tutorialspoint.com/radix-sort-in-javascript}\n * @param {Object[]} arr The array to be sorted.\n * @returns {any[]} Animation array which contains the animation instruction for each step.\n */\nconst radixSort = (arr) => {\n  let inputArr = arr;\n  let animationArr = [];\n  const maxNum = Math.max(...inputArr.map((x) => x.height)) * 10;\n  let divisor = 10;\n  while (divisor < maxNum) {\n    let id = 0;\n    let buckets = [...Array(10)].map(() => []);\n\n    for (const item of inputArr) {\n      const height = item.height;\n      const location = Math.floor((height % divisor) / (divisor / 10));\n      buckets[location].push(item);\n      animationArr.push({\n        id: id,\n        height: item.height,\n        isShown: true,\n        location: location,\n        isDistributing: true,\n      });\n      id++;\n    }\n    inputArr = [].concat.apply([], buckets);\n    id = 0;\n    let location = 0;\n    for (const array of buckets) {\n      for (const item of array) {\n        animationArr.push({\n          id: id,\n          height: item.height,\n          isShown: true,\n          location: location,\n          isDistributing: false,\n        });\n        id++;\n      }\n      location++;\n    }\n    divisor *= 10;\n  }\n  return animationArr;\n};\n\nexport default radixSort;\n","/**\n * Sorts the array using Counting Sort and stores each sorting step into the animation array.\n *\n * @memberOf SortingAlgorithms\n * @param {Object[]} arr The array to be sorted.\n * @returns {any[]} Animation array which contains the animation instruction for each step.\n */\nconst countingSort = (arr) => {\n  let receivedArr = arr;\n  let countArr = [...Array(10)].map(() => 0);\n  for (let i = 0; i < receivedArr.length; i++) {\n    countArr[receivedArr[i].height]++;\n  }\n  let id = 0;\n  for (let i = 0; i < countArr.length; i++) {\n    while (countArr[i] !== 0) {\n      receivedArr.push({\n        id: id,\n        height: i,\n        isShown: true,\n      });\n      id++;\n      countArr[i]--;\n    }\n  }\n  return receivedArr;\n};\n\nexport default countingSort;\n","import { swap } from './swap';\n\n/**\n * Sorts the array using Selection Sort and stores each sorting step into the animation array.\n *\n * @memberOf SortingAlgorithms\n * @param {Object[]} arr The array to be sorted.\n * @returns {any[]} Animation array which contains the animation instruction for each step.\n */\nconst selectionSort = (arr) => {\n  let receivedArr = arr;\n  let animationArr = [];\n  for (let i = 0; i < receivedArr.length - 1; i++) {\n    let smallestIdx = i;\n    for (let j = i + 1; j < receivedArr.length; j++) {\n      animationArr.push([smallestIdx, j, false]);\n      if (receivedArr[j].height < receivedArr[smallestIdx].height) {\n        smallestIdx = j;\n      }\n    }\n    if (i !== smallestIdx) {\n      swap(smallestIdx, i, receivedArr);\n      animationArr.push([smallestIdx, i, true]);\n    }\n  }\n  return animationArr;\n};\n\nexport default selectionSort;\n","import { swap } from './swap';\n\n/**\n * Sorts the array using Shell Sort and stores each sorting step into the animation array.\n *\n * @memberOf SortingAlgorithms\n * @see {@link https://levelup.gitconnected.com/shell-sort-in-javascript-c8a487041cdb}\n * @param {Object[]} arr The array to be sorted.\n * @returns {any[]} Animation array which contains the animation instruction for each step.\n */\nconst shellSort = (arr) => {\n  let n = arr.length;\n  let receivedArr = arr;\n  let animationArr = [];\n\n  for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {\n    for (let i = gap; i < n; i += 1) {\n      let temp = receivedArr[i].height;\n\n      let j;\n      for (j = i; j >= gap; j -= gap) {\n        animationArr.push([j - gap, j, false]);\n        if (receivedArr[j - gap].height > temp) {\n          animationArr.push([j - gap, j, true]);\n          swap(j - gap, j, receivedArr);\n          continue;\n        }\n        break;\n      }\n    }\n  }\n\n  return animationArr;\n};\n\nexport default shellSort;\n","import { generateValue } from './MathUtil';\nimport { generateMergeSortArray } from './MergeSortUtil';\nimport { generateCountSortArray } from './CountingSortUtil';\nimport { generateRadixSortArray } from './RadixSortUtil';\nimport { generateBucketSortArray } from './BucketSortUtil';\nimport SortingAlgorithms from '../../algorithm/sortingalgorithms/allSorts';\nimport { isCountingSort, isMergeSort, isRadixOrBucket } from './GeneralUtil';\n\n/**\n * Resets the given array.\n *\n * @method\n * @category ArrayUtil\n * @param {string} visualizerAlgorithm Algorithm used.\n * @param {Object[]} arr Array to be reset.\n * @returns {Object[]} Array that has been reset.\n */\nexport const resetArray = (visualizerAlgorithm, arr) => {\n  if (isRadixOrBucket(visualizerAlgorithm)) {\n    return arrayCopy(arr);\n  }\n\n  return arrayCopy(arr).map((x) => {\n    let tempArrElement = x;\n    if (isCountingSort(visualizerAlgorithm)) {\n      tempArrElement.isShown = true;\n    } else if (isMergeSort(visualizerAlgorithm)) {\n      tempArrElement.isShift = false;\n    } else {\n      tempArrElement.isSwap = false;\n    }\n    return tempArrElement;\n  });\n};\n\n/**\n * Creates a deep copy of the array.\n *\n * @method\n * @category ArrayUtil\n * @param {Object[]} arr Array to be copied.\n * @returns {Object[]} Deep copy of the input array.\n */\nexport const arrayCopy = (arr) => {\n  return JSON.parse(JSON.stringify(arr));\n};\n\n/**\n * Retrieves the animation array based on the given array and algorithm selected.\n *\n * @method\n * @category ArrayUtil\n * @param {string} visualizerAlgorithm The current algorithm of the visualizer.\n * @param {Object[]} arrayData Given array.\n * @returns {any[]} An array that contains all the animation steps.\n */\nexport const getAnimationArr = (visualizerAlgorithm, arrayData) => {\n  const sortAlgo = SortingAlgorithms[visualizerAlgorithm];\n  return sortAlgo(arrayCopy(arrayData));\n};\n\n/**\n * Object used to map the names of each algorithm to its generated array.\n *\n * @method\n * @category ArrayUtil\n * @const {Object}\n */\nconst arrayGenerator = {\n  'Insertion Sort': (size) => generateDefaultArray(size),\n  'Bubble Sort': (size) => generateDefaultArray(size),\n  'Quick Sort': (size) => generateDefaultArray(size),\n  'Shell Sort': (size) => generateDefaultArray(size),\n  'Heap Sort': (size) => generateDefaultArray(size),\n  'Selection Sort': (size) => generateDefaultArray(size),\n  'Merge Sort': (size) => generateMergeSortArray(size),\n  'Counting Sort': (size) => generateCountSortArray(size),\n  'Radix Sort': (size) => generateRadixSortArray(size),\n  'Bucket Sort': (size) => generateBucketSortArray(size),\n};\n\n/**\n * Generates a random array based on the size chosen and the algorithm selected.\n *\n * @method\n * @category ArrayUtil\n * @param {number} size Size of array selected by user.\n * @param {string} visualizerAlgorithm The current algorithm of the visualizer.\n * @returns {Object[]} Random array generated.\n */\nexport const generateArray = (size, visualizerAlgorithm) => {\n  return arrayGenerator[visualizerAlgorithm](size);\n};\n\n/**\n * Generates the default array. Used by all sorting algorithms involving swaps only.\n *\n * @category ArrayUtil\n * @param {number} size Size of array selected by user.\n * @returns {Object[]} Random array generated.\n */\nconst generateDefaultArray = (size) => {\n  let array = [];\n  for (let i = 0; i < size; i++) {\n    array.push({\n      id: i,\n      height: generateValue(5, 20),\n      isSwap: false,\n    });\n  }\n  return array;\n};\n","import React, { useContext, useState } from 'react';\nimport { Dropdown, Menu } from 'antd';\nimport { DownOutlined } from '@ant-design/icons';\nimport { VisualizerStateContext } from '../../../Visualizer';\nimport 'antd/dist/antd.css';\nimport { isRadixOrBucket } from '../../../util/GeneralUtil';\nimport { buckets } from '../../../util/CountingSortUtil';\nimport './styles.css';\nimport { stack } from '../../../util/RadixSortUtil';\nimport { arrayCopy, generateArray } from '../../../util/ArrayUtil';\n\n/**\n * A drop down menu which allows users to pick their algorithm for the visualizer.\n *\n * @component\n * @category Visualizer\n */\nconst AlgorithmChooser = () => {\n  const {\n    dataSize,\n    setDataSize,\n    isPlay,\n    isInMidstOfSort,\n    setIsReplay,\n    setIsInMidstOfSort,\n    setVisualizerAlgorithm,\n    setArrayData,\n    setAnimationPercentage,\n    setIsReset,\n    setCountArr,\n    setStackArr,\n    setHistoryArr,\n  } = useContext(VisualizerStateContext);\n\n  const [algorithm, setAlgorithm] = useState('Bubble Sort');\n\n  /**\n   * List of available Algorithms available in Sort-Algo.\n   */\n  const listOfAlgorithm = [\n    { algorithmName: 'Bubble Sort', key: '0' },\n    { algorithmName: 'Insertion Sort', key: '1' },\n    { algorithmName: 'Selection Sort', key: '2' },\n    { algorithmName: 'Merge Sort', key: '3' },\n    { algorithmName: 'Quick Sort', key: '4' },\n    { algorithmName: 'Heap Sort', key: '5' },\n    { algorithmName: 'Shell Sort', key: '6' },\n    { algorithmName: 'Counting Sort', key: '7' },\n    { algorithmName: 'Radix Sort', key: '8' },\n    { algorithmName: 'Bucket Sort', key: '9' },\n  ];\n\n  /**\n   * Retrieves the algorithm name being chosen and set the system's algorithm to the selected algorithm.\n   *\n   * @param algorithmName Algorithm which is chosen via the drop down menu.\n   */\n  const handleMenuClick = (algorithmName) => {\n    setAlgorithm(algorithmName);\n    setVisualizerAlgorithm(algorithmName);\n    if (algorithm !== algorithmName) {\n      if (isInMidstOfSort) {\n        setIsInMidstOfSort(false);\n      }\n      if (dataSize > 10 && isRadixOrBucket(algorithmName)) {\n        setArrayData(generateArray(10, algorithmName));\n        setDataSize(10);\n      } else {\n        setArrayData(generateArray(dataSize, algorithmName));\n      }\n      setIsReplay(false);\n      setIsReset(true);\n      setCountArr(arrayCopy(buckets));\n      setStackArr(arrayCopy(stack));\n      setHistoryArr([]);\n      setAnimationPercentage(0);\n    }\n  };\n\n  /**\n   * A drop down list which displays a list of algorithms available in Sort-Algo.\n   *\n   * @type {JSX.Element}\n   */\n  const menu = (\n    <Menu>\n      {listOfAlgorithm.map(({ algorithmName, key }) => {\n        return (\n          <Menu.Item\n            key={key}\n            onClick={() => handleMenuClick(algorithmName)}\n            style={{ color: '#8789B5' }}\n          >\n            {algorithmName}\n          </Menu.Item>\n        );\n      })}\n    </Menu>\n  );\n\n  return (\n    <div\n      className=\"algorithm-selector-holder\"\n      style={{ cursor: isPlay ? 'not-allowed' : 'cursor' }}\n    >\n      <Dropdown overlay={menu} trigger={['click']} placement={'bottomCenter'} disabled={isPlay}>\n        <a\n          className=\"ant-dropdown-link\"\n          onClick={(e) => e.preventDefault()}\n          id=\"algorithm-selector-drop-down-arrow\"\n        >\n          {algorithm}\n          <DownOutlined\n            style={{ transform: 'translateX(5px)', cursor: isPlay ? 'not-allowed' : 'cursor' }}\n          />\n        </a>\n      </Dropdown>\n    </div>\n  );\n};\n\nexport default AlgorithmChooser;\n","import React, { useContext, useState } from 'react';\nimport { Slider } from 'antd';\nimport 'antd/dist/antd.css';\nimport './styles.css';\nimport { VisualizerStateContext } from '../../../Visualizer';\nimport { isRadixOrBucket } from '../../../util/GeneralUtil';\n\n/**\n * A generic component for the slider.\n *\n * @component\n * @category Visualizer\n * @param {function} setData A method to change the data upon sliding.\n * @param {number} min The minimum value for the slider.\n * @param {number} max The maximum value for the slider.\n * @param {string} name The name to be displayed for the slider.\n * @returns {JSX.Element} A slider component that is bounded by {@code min} and {@code max}.\n */\nconst SliderSelector = ({ setData, min, max, name }) => {\n  const { isPlay, visualizerAlgorithm } = useContext(VisualizerStateContext);\n\n  const maxSize = isRadixOrBucket(visualizerAlgorithm) ? 10 : max;\n\n  const [sliderData, setSliderData] = useState(() => Math.floor((min + maxSize) / 2));\n\n\n  return (\n    <div className=\"selector-holder\">\n      <span>\n        {name}: {sliderData}\n      </span>\n      <Slider\n        defaultValue={Math.floor((min + maxSize) / 2)}\n        min={min}\n        max={maxSize}\n        onChange={(val) => {setSliderData(val); setData(val)}}\n        disabled={isPlay}\n      />\n    </div>\n  );\n};\n\nexport default SliderSelector;\n","import { executeSwap } from './SwappingAlgoUtil';\n\n/**\n * A sorting execution for Quick Sort.\n *\n * @method\n * @category QuickSortUtil\n * @param {any[]} currentAnimation The current animation to be executed.\n * @param {Object[]} referenceArray The array holding data for the \"blocks\".\n * @param {string} visualizerAlgorithm The current algorithm of the visualizer.\n * @param {function} setReferenceArray A set state method for reference array.\n * @returns {Object[]} The resultant array upon the swap animation.\n */\nexport const executeQuickSort = (\n  currentAnimation,\n  referenceArray,\n  visualizerAlgorithm,\n  setReferenceArray\n) => {\n  if (typeof currentAnimation !== 'undefined') {\n    let firstIdx = currentAnimation[1];\n    let secondIdx = currentAnimation[0];\n    let pivotIdx = currentAnimation[3];\n    let isSwapOccurring = currentAnimation[2];\n    let arrToUse = executeSwapWithPivot(\n      firstIdx,\n      secondIdx,\n      pivotIdx,\n      referenceArray,\n      isSwapOccurring,\n      visualizerAlgorithm\n    );\n    setReferenceArray(arrToUse);\n    return arrToUse;\n}\nelse {\n  return 0;\n}\n};\n\n/**\n * A sorting execution for Quick Sort\n *\n * @method\n * @category QuickSortUtil\n * @param {number} firstIdx The first index to be swapped\n * @param {number} secondIdx The second index to be swapped\n * @param {number} pivotIdx The pivot index that is being compared to\n * @param {Object[]} arr The array which the index at {@code firstIdx} and {@code secondIdx} is swapped\n * @param {boolean} isSwapOccurring A boolean value denoting whether a swap will occur\n * @param {string} visualizerAlgorithm The current algorithm of the visualizer\n * @returns {Object[]} A new Object array which has been been swap and highlighted or just highlighted\n */\nexport const executeSwapWithPivot = (\n  firstIdx,\n  secondIdx,\n  pivotIdx,\n  arr,\n  isSwapOccurring,\n  visualizerAlgorithm\n) => {\n  let newTempArr = executeSwap(firstIdx, secondIdx, arr, isSwapOccurring, visualizerAlgorithm);\n  newTempArr[pivotIdx].isSwap = true;\n  return newTempArr;\n};\n","export const SpeedSelectorProps = {\n  min: 1,\n  max: 10,\n  name: 'Speed',\n};\n\nexport const DataSizeSelectorProps = {\n  min: 5,\n  max: 25,\n  name: 'Size',\n};\n","import React, { useContext } from 'react';\nimport 'antd/dist/antd.css';\nimport { Progress } from 'antd';\nimport { VisualizerStateContext } from '../../Visualizer';\n\n/**\n * Progress bar for the animation completion.\n *\n * @component\n * @category Visualizer\n */\nconst AnimationProgressBar = () => {\n  const { animationPercentage } = useContext(VisualizerStateContext);\n  return (\n    <div style={{ width: 300, transform: 'translateY(60px)' }}>\n      <Progress\n        status={'normal'}\n        strokeColor={{\n          '0%': '#287ED0',\n          '100%': '#5466FF',\n        }}\n        percent={animationPercentage}\n      />\n    </div>\n  );\n};\n\nexport default AnimationProgressBar;\n","import React, { useContext } from 'react';\nimport './styles.css';\nimport { VisualizerStateContext } from '../../Visualizer';\n\n/**\n * A counting sort block which represents a data item in the array.\n *\n * @component\n * @category Block\n * @param item Data item from the reference array.\n * @returns {JSX.Element}\n */\nconst CountingSortBlock = ({ item }) => {\n  const { dataSize } = useContext(VisualizerStateContext);\n\n  return (\n    <div\n      className=\"animated-block\"\n      style={{\n        backgroundImage: `linear-gradient(45deg, #287ED0, #5466FF)`,\n        height: item.height * 10 + 9,\n        width: 800 / dataSize,\n        visibility: item.isShown ? `visible` : `hidden`,\n      }}\n    >\n      <span>{item.height}</span>\n    </div>\n  );\n};\n\nexport default CountingSortBlock;\n","import React from 'react';\nimport './styles.css';\n\n/**\n * Horizontal array representation of the entire array.\n *\n * @component\n * @category MultipleBlocks\n * @param referenceArray Current state of the data array.\n * @param BlockType Used to represent each item in the data array.\n * @returns {JSX.Element} Horizontal array component.\n */\nconst HorizontalArray = ({ referenceArray, BlockType }) => {\n  return (\n    <div className=\"horiz-arr\">\n      {referenceArray.map((x) => (\n        <BlockType item={x} key={x.id} />\n      ))}\n    </div>\n  );\n};\n\nexport default HorizontalArray;\n","import React, { useContext } from 'react';\nimport './styles.css';\nimport { VisualizerStateContext } from '../../Visualizer';\n\n/**\n * A count block used to collect items from the reference array.\n *\n * @component\n * @category Block\n * @returns {JSX.Element} Count block component.\n */\nconst CountBlock = ({ item }) => {\n  const { dataSize } = useContext(VisualizerStateContext);\n\n  /**\n   * Color array used to represent the intensity of the highlight for each block.\n   *\n   * @const {string[]}\n   */\n  const colorArr = [\n    '#B8B8B8',\n    '#b4d3de',\n    '#7AC1DB',\n    '#74a2d6',\n    '#7B9AD6',\n    '#6A8FDB',\n    '#5480D9',\n    '#3B6DD2',\n    '#3b5cd2',\n    '#274ac8',\n    '#1e41c8',\n    '#183cc6',\n    '#092ec8',\n    '#091cc8',\n    '#0600c3',\n    '#0600a0',\n    '#030062',\n    '#030030',\n    '#030016',\n    '#000000',\n    '#000000',\n    '#000000',\n    '#000000',\n    '#000000',\n    '#000000',\n  ];\n\n  return (\n    <div className=\"fixed-array-container\">\n      <div\n        className=\"animated-block\"\n        style={{\n          height: item.height * 10 + 9,\n          backgroundColor: colorArr[item.count],\n          width: 800 / Math.max(dataSize, 9),\n        }}\n      >\n        <span>{item.height}</span>\n      </div>\n      <span className=\"count\">{item.count}</span>\n    </div>\n  );\n};\n\nexport default CountBlock;\n","import React, { useContext } from 'react';\nimport CountingSortBlock from '../block/CountingSortBlock';\nimport './styles.css';\nimport { VisualizerStateContext } from '../../Visualizer';\nimport HorizontalArray from '../multipleblocks/HorizontalArray';\nimport CountBlock from '../block/CountBlock';\n\n/**\n * Counting sort screen which encapsulates the fields and components of the animation.\n *\n * @component\n * @category AnimationScreen\n * @returns {JSX.Element} Counting sort screen component.\n */\nconst CountingSortScreen = () => {\n  const { referenceArray, countArr } = useContext(VisualizerStateContext);\n\n  return (\n    <div className=\"container-one\">\n      <HorizontalArray referenceArray={referenceArray} BlockType={CountingSortBlock} />\n      <div style={{ marginTop: `6%` }}>\n        <HorizontalArray referenceArray={countArr} BlockType={CountBlock} />\n      </div>\n    </div>\n  );\n};\n\nexport default CountingSortScreen;\n","import React from 'react';\n\n/**\n * Retrieves the current digit to highlight.\n *\n * @category HighlightUtil\n * @param {number} idx Index of the current animation.\n * @param {number} dataSize Size of data array.\n * @returns {number} Digit to highlight.\n */\nconst getDigitToHighlight = (idx, dataSize) => {\n  if (idx < 2 * dataSize) {\n    return 1;\n  } else if (idx < 4 * dataSize) {\n    return 2;\n  } else if (idx < 6 * dataSize) {\n    return 3;\n  } else {\n    // No highlight case\n    return -1;\n  }\n};\n\n/**\n * Highlights a digit in the value based on the current stage of the animation.\n *\n * @method\n * @category HighlightUtil\n * @param {number} value Value of element.\n * @param {number} idx Current index of the animation.\n * @param {number} dataSize Size of data selected.\n * @returns {JSX.Element[]} Array of digits.\n */\nexport const highlightDigit = (value, idx, dataSize) => {\n  const currentHighlighted = getDigitToHighlight(idx, dataSize);\n  let current = 0;\n  let index = 1;\n  let numberMapping = [];\n  while (value > 0) {\n    current = value % 10;\n    numberMapping.push([current, currentHighlighted === index]);\n    index++;\n    value = Math.floor(value / 10);\n  }\n  return numberMapping.map((x) => (\n    <span style={{ fontWeight: x[1] && `bold`, color: x[1] && `#fff` }}>{x[0]}</span>\n  ));\n};\n\n/**\n * Spreads the number into spans of digits.\n *\n * @method\n * @category HighlightUtil\n * @param {number} value Number to spread.\n * @returns {JSX.Element[]} Array of digits.\n */\nexport const spreadNumber = (value) => {\n  let stringArray = Array.from(value.toString());\n  return stringArray.map((x) => <span>{x}</span>);\n};\n","import { highlightDigit } from './HighlightUtil';\nimport React, { useContext } from 'react';\nimport { VisualizerStateContext } from '../../Visualizer';\nimport './styles.css';\n\n/**\n * Single oval to represent an item in the reference array.\n *\n * @component\n * @category Block\n * @param {Object} item Element in the reference array.\n * @param {boolean} display States if the oval should be highlighted.\n * @param {number} marginTop Margin\n * @returns {JSX.Element} Single oval containing the item.\n */\nconst HighlightedOval = ({ item, display, marginTop }) => {\n  const { idx, dataSize } = useContext(VisualizerStateContext);\n\n  return (\n    <div\n      className=\"oval\"\n      style={{\n        visibility: display || item.isShown ? `visible` : `hidden`,\n        marginTop: marginTop,\n      }}\n    >\n      <div className=\"reversed-number\">{highlightDigit(item.height, idx, dataSize)}</div>\n    </div>\n  );\n};\n\nexport default HighlightedOval;\n","import React from 'react';\nimport HighlightedOval from '../block/HighlightedOval';\n\n/**\n * Stack of boxes of an item in the bucket for radix sort.\n *\n * @component\n * @category MultipleBlocks\n * @param {Object} individualStack A single stack in the buckets.\n * @returns {JSX.Element} Stack of boxes component.\n */\nconst StackOfBoxes = ({ individualStack }) => (\n  <div className=\"stack\">\n    <div className=\"stack-boxes\">\n      {individualStack.array.map((x) => (\n        <HighlightedOval item={x} key={x.id} display={true} marginTop={10} />\n      ))}\n    </div>\n    <div className=\"number-with-line\">{individualStack.value}</div>\n  </div>\n);\n\nexport default StackOfBoxes;\n","import React, { useContext } from 'react';\nimport { VisualizerStateContext } from '../../Visualizer';\nimport './styles.css';\nimport '../multipleblocks/styles.css';\nimport HorizontalArray from '../multipleblocks/HorizontalArray';\nimport HighlightedOval from '../block/HighlightedOval';\nimport StackOfBoxes from '../multipleblocks/StackOfBoxes';\n\n/**\n * Radix sort screen which encapsulates the fields and components of the animation.\n *\n * @component\n * @category AnimationScreen\n * @returns {JSX.Element} Radix sort screen component.\n */\nconst RadixSortScreen = () => {\n  const { referenceArray, stackArr } = useContext(VisualizerStateContext);\n\n  return (\n    <div className=\"container-one\" style={{ justifyContent: `space-between`, minHeight: 370 }}>\n      <HorizontalArray referenceArray={referenceArray} BlockType={HighlightedOval} />\n      <div className=\"stack-arr\">\n        {stackArr.map((stack) => (\n          <StackOfBoxes individualStack={stack} key={stack.value} />\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default RadixSortScreen;\n","import React from 'react';\nimport { animated } from 'react-spring';\nimport { spreadNumber } from './HighlightUtil';\nimport './styles.css';\n\n/**\n * A bucket sort block which animates to show the sorting animation.\n *\n * @component\n * @category Block\n * @param {Object} item The information of the block.\n * @param {Object} x The displacement of the block.\n * @param {Object} rest All other information of the props.\n * @returns {JSX.Element} An animated block which translates in the y direction.\n */\nconst BucketSortBlock = ({ item, props: { y, ...rest } }) => {\n  return (\n    <animated.div\n      className=\"oval\"\n      style={{\n        ...rest,\n        height: 40,\n        backgroundImage: item.isSwap\n          ? `linear-gradient(45deg, #13B1B7, #11C2C9)`\n          : `linear-gradient(45deg, #287ED0, #5466FF)`,\n        transform: y.interpolate((y) => `translate3d(0,${y}px,0)`),\n      }}\n    >\n      <div className=\"decimal\">{spreadNumber(item.height)}</div>\n    </animated.div>\n  );\n};\n\nexport default BucketSortBlock;\n","import React from 'react';\nimport { useTransition } from 'react-spring';\nimport BucketSortBlock from '../block/BucketSortBlock';\nimport './styles.css';\n\n/**\n * Animated stack of boxes used for bucket sort.\n *\n * @component\n * @category MultipleBlocks\n * @param {any[]} individualStack Individual bucket in the stack.\n * @param {number} value Index of the stack.\n * @returns {JSX.Element} Stack of boxes component.\n */\nconst StackOfAnimatedBoxes = ({ individualStack, value }) => {\n  let yDirection = 0;\n\n  // Transition for the single stack\n  const transition = useTransition(\n    individualStack.map((data) => {\n      return { ...data, y: (yDirection -= 10) + 10 };\n    }),\n    (d) => d.id,\n    {\n      from: { height: 0, opacity: 1 },\n      leave: { height: 0, opacity: 1 },\n      enter: ({ y, height }) => ({ y, height, opacity: 1 }),\n      update: ({ y, height }) => ({ y, height }),\n    }\n  );\n\n  return (\n    <div className=\"stack\">\n      <div className=\"stack-boxes\">\n        {transition.map(({ item, props: { y, ...rest } }) => (\n          <BucketSortBlock item={item} props={{ y, ...rest }} key={item.id} />\n        ))}\n      </div>\n      <div className=\"number-with-line\">{value}</div>\n    </div>\n  );\n};\n\nexport default StackOfAnimatedBoxes;\n","import { spreadNumber } from './HighlightUtil';\nimport React from 'react';\nimport './styles.css';\n\n/**\n * Single oval to represent an item in the reference array.\n *\n * @component\n * @category Block\n * @param {Object} item Element in the reference array.\n * @returns {JSX.Element} Single oval containing the item.\n */\nconst Oval = ({ item }) => (\n  <div\n    className=\"oval\"\n    style={{\n      visibility: item.isShown ? `visible` : `hidden`,\n    }}\n  >\n    <div className=\"decimal\">{spreadNumber(item.height)}</div>\n  </div>\n);\n\nexport default Oval;\n","import React, { useContext } from 'react';\nimport { VisualizerStateContext } from '../../Visualizer';\nimport StackOfAnimatedBoxes from '../multipleblocks/StackOfAnimatedBoxes';\nimport './styles.css';\nimport HorizontalArray from '../multipleblocks/HorizontalArray';\nimport Oval from '../block/Oval';\n\n/**\n * Bucket sort screen which encapsulates the fields and components of the animation.\n *\n * @component\n * @category AnimationScreen\n * @returns {JSX.Element} Bucket sort screen component.\n */\nconst BucketSortScreen = () => {\n  const { referenceArray, stackArr } = useContext(VisualizerStateContext);\n\n  return (\n    <div className=\"spaced-out-container\">\n      <HorizontalArray referenceArray={referenceArray} BlockType={Oval} />\n      <div className=\"stack-arr\">\n        {stackArr.map((stack) => (\n          <StackOfAnimatedBoxes\n            individualStack={stack.array}\n            value={stack.value}\n            key={stack.value}\n          />\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default BucketSortScreen;\n","import React from 'react';\nimport './styles.css';\nimport { animated } from 'react-spring';\n\n/**\n * A block which animates to show the Merge Sort algorithm.\n *\n * @component\n * @category Block\n * @param {Object} item The information of the block.\n * @param {number} x The displacement of the block in the X-Direction.\n * @param {Object} rest All other information of the props.\n * @param {number} length The number of blocks.\n * @param {number} index Index of the block.\n * @param {boolean} isSwap A boolean value denoting whether this block is in a shift animation.\n * @param {number} width Width of the block.\n * @returns {JSX.Element} An animated block which translate in either the X or Y-Direction.\n */\nconst MergeSortBlock = ({ item, props: { x, ...rest }, length, index, isShift, width }) => {\n  return (\n    <animated.div\n      className=\"animated-block\"\n      style={{\n        ...rest,\n        height: item.height * 10 + 9,\n        width: width,\n        zIndex: length - index,\n        transform: isShift\n          ? x.interpolate((x) => `translate3d(${x}px, 150px,0)`)\n          : x.interpolate((x) => `translate3d(${x}px,0,0)`),\n        backgroundImage: isShift\n          ? `linear-gradient(45deg, #13B1B7, #11C2C9)`\n          : `linear-gradient(45deg, #287ED0, #5466FF)`,\n        pos: item.pos,\n        prevPos: item.prevPos,\n      }}\n    >\n      <span>{item.height}</span>\n    </animated.div>\n  );\n};\n\nexport default MergeSortBlock;\n","/**\n * Generates a translation in the x direction to shift the animation screen when the data size\n * is more than 12.\n *\n * @method\n * @category VisualizerUtil\n * @param {number} dataSize Data size.\n * @returns {number} Translation in the x direction when the data size is more than 12.\n */\nexport const translateXOfVisualizer = (dataSize) => {\n  if (dataSize > 12) {\n    let singleBlockWidth = 200 / dataSize;\n    return (dataSize - 12) * singleBlockWidth;\n  }\n  return 0;\n};\n","import React from 'react';\nimport MergeSortBlock from '../block/MergeSortBlock';\nimport './styles.css';\nimport { translateXOfVisualizer } from './AnimationScreenUtil';\n\n/**\n * Animation screen which shows the Merge Sort algorithm.\n *\n * @component\n * @category AnimationScreen\n * @param {Object[]} transitions An array which contains the animated blocks.\n * @param {number} dataSize The number of blocks.\n * @returns {JSX.Element} Merge sort screen component.\n */\nconst MergeSortScreen = ({ transitions, dataSize }) => {\n  return (\n    <div className=\"container-one\">\n      <div\n        className=\"list\"\n        style={{\n          transform: `translateX(-${translateXOfVisualizer(dataSize)}px)`,\n        }}\n      >\n        {transitions.map(({ item, props: { x, ...rest } }, index) => {\n          return (\n            <MergeSortBlock\n              item={item}\n              props={{ x, ...rest }}\n              index={index}\n              length={dataSize}\n              key={index}\n              isShift={item.isShift}\n              width={800 / dataSize}\n              pos={item.pos}\n              prevPos={item.prevPos}\n            />\n          );\n        })}\n      </div>\n      <div className=\"empty-space-for-merge-sort\" />\n    </div>\n  );\n};\n\nexport default MergeSortScreen;\n","import React from 'react';\nimport './styles.css';\nimport { animated } from 'react-spring';\n\n/**\n * A block which animates to show the sorting animation.\n *\n * @component\n * @category Block\n * @param {Object} item The information of the block.\n * @param {number} x The displacement of the block in the X-Direction.\n * @param {Object} rest All other information of the props.\n * @param {number} length The number of blocks.\n * @param {number} index Index of the block.\n * @param {boolean} isSwap A boolean value denoting whether this block is in a swap animation.\n * @param {number} width Width of the block.\n * @returns {JSX.Element} An animated block which translate in the X-Direction.\n */\nconst AnimatedBlock = ({ item, props: { x, ...rest }, length, index, isSwap, width }) => {\n  return (\n    <animated.div\n      className=\"animated-block\"\n      style={{\n        ...rest,\n        height: item.height * 10,\n        width: width,\n        zIndex: length - index,\n        transform: x.interpolate((x) => `translate3d(${x}px,0,0)`),\n        backgroundImage: isSwap\n          ? `linear-gradient(45deg, #13B1B7, #11C2C9)`\n          : `linear-gradient(45deg, #287ED0, #5466FF)`,\n      }}\n    >\n      <span>{item.height}</span>\n    </animated.div>\n  );\n};\n\nexport default AnimatedBlock;\n","import React from 'react';\nimport AnimatedBlock from '../block/AnimatedBlock';\nimport './styles.css';\nimport { translateXOfVisualizer } from './AnimationScreenUtil';\n\n/**\n * Animation screen which shows the Insertion, Bubble, Selection, Shell Sort algorithm.\n *\n * @component\n * @category AnimationScreen\n * @param {Object[]} transitions An array which contains the animated blocks.\n * @param {number} dataSize The number of blocks.\n * @returns {JSX.Element} Generic sort screen component.\n */\nconst GenericSortScreen = ({ transitions, dataSize }) => {\n  return (\n    <div\n      className=\"list\"\n      style={{\n        transform: `translateX(-${translateXOfVisualizer(dataSize)}px)`,\n      }}\n    >\n      {transitions.map(({ item, props: { x, ...rest } }, index) => {\n        return (\n          <AnimatedBlock\n            item={item}\n            props={{ x, ...rest }}\n            index={index}\n            length={dataSize}\n            key={index}\n            isSwap={item.isSwap}\n            width={800 / dataSize}\n          />\n        );\n      })}\n    </div>\n  );\n};\n\nexport default GenericSortScreen;\n","import React, { useContext, useEffect } from 'react';\nimport { useTransition } from 'react-spring';\nimport './styles.css';\nimport { VisualizerStateContext } from '../../Visualizer';\nimport { isBucketSort, isCountingSort, isMergeSort, isRadixSort } from '../../util/GeneralUtil';\nimport CountingSortScreen from './CountingSortScreen';\nimport RadixSortScreen from './RadixSortScreen';\nimport BucketSortScreen from './BucketSortScreen';\nimport MergeSortScreen from './MergeSortScreen';\nimport GenericSortScreen from './GenericSortScreen';\nimport { arrayCopy } from '../../util/ArrayUtil';\n\n/**\n * The screen which shows the animation for the sorting visualizer.\n *\n * @component\n * @category Visualizer\n * @returns {JSX.Element} Animation sort screen component.\n */\nconst AnimationScreen = () => {\n  const {\n    isPlay,\n    isReplay,\n    arrayData,\n    animationArr,\n    idx,\n    referenceArray,\n    speed,\n    setIdx,\n    setReferenceArray,\n    executeForwardAnimation,\n    resetDataWhenAnimationFinish,\n    dataSize,\n    visualizerAlgorithm,\n    isReset,\n    setIsReset,\n    setIsReplay,\n    setIsPlay,\n  } = useContext(VisualizerStateContext);\n  const animationSpeedArray = [1000, 800, 600, 500, 400, 320, 260, 200, 160, 120];\n  let xDirection = 0;\n\n  useEffect(() => {\n    /**\n     * This is for replay, or any changes to arrayData\n     */\n    if (isReset) {\n      setReferenceArray(arrayCopy(arrayData));\n      setIdx(0);\n      setIsReset(false);\n    }\n  }, [arrayData, isReplay]);\n\n  /**\n   * This is the loop animation and ending of animation screen.\n   * If block is to do the loop animation.\n   * Else Block is to change the state into replay.\n   */\n  useEffect(() => {\n    if (!isReplay && isPlay && idx <= animationArr.length) {\n      setTimeout(() => {\n        executeForwardAnimation();\n      }, animationSpeedArray[speed - 1]);\n    } else if (!isReplay && isPlay) {\n      //resetDataWhenAnimationFinish(referenceArray);\n    }\n  }, [isPlay, idx]);\n\n  const transitions = useTransition(\n    referenceArray.map((data) => {\n      if (isMergeSort(visualizerAlgorithm)) {\n        return { ...data, x: parseInt(data.xDirection) };\n      }\n      return { ...data, x: (xDirection += 10) - 10 };\n    }),\n    (d) => d.id,\n    {\n      from: { height: 0, opacity: 1 },\n      leave: { height: 0, opacity: 1 },\n      enter: ({ x, height }) => ({ x, height, opacity: 1 }),\n      update: ({ x, height }) => ({ x, height }),\n    }\n  );\n\n  const dataItem = {\n    transitions: transitions,\n    dataSize: dataSize,\n  };\n\n  if (isCountingSort(visualizerAlgorithm)) {\n    return <CountingSortScreen />;\n  } else if (isRadixSort(visualizerAlgorithm)) {\n    return <RadixSortScreen />;\n  } else if (isBucketSort(visualizerAlgorithm)) {\n    return <BucketSortScreen />;\n  } else if (isMergeSort(visualizerAlgorithm)) {\n    return <MergeSortScreen {...dataItem} />;\n  } else {\n    return <GenericSortScreen {...dataItem} />;\n  }\n};\n\nexport default AnimationScreen;\n","\n/**\n * Generates the step by step template for Insertion, Bubble, Selection, Shell Sort.\n *\n * @method\n * @memberOf StepByStepTemplate\n * @param {any[]} animationArr An array that contains all the animation steps.\n * @param {number} idx Index of the current animation step.\n * @param {Object[]} referenceArray An array containing the data which is being sorted.\n * @returns {string} The information regarding the current step of the animation.\n */\nexport const genericSwapStepByStep = (animationArr, idx, referenceArray) => {\n  if (idx >= animationArr.length) {\n    return 'Array is sorted';\n  }\n  if (idx > 0 && idx < animationArr.length) {\n    let animationArrSwapIdx = animationArr[idx - 1];\n    let firstIdx = animationArrSwapIdx[0];\n    let secondIdx = animationArrSwapIdx[1];\n    let isSwap = animationArrSwapIdx[2];\n    let firstIdxVal = referenceArray[firstIdx].height;\n    let secondIdxVal = referenceArray[secondIdx].height;\n    let isBigger = secondIdxVal > firstIdxVal;\n\n    if (isSwap) {\n      return `Since swap is true, swap ${secondIdxVal} and ${firstIdxVal}`;\n    }\n\n    // Comparisons message\n    let message = `Check if ${secondIdxVal} > ${firstIdxVal} :\\n`;\n\n    if (isBigger) {\n      message += `Since ${secondIdxVal} > ${firstIdxVal}, swap is set to true`;\n    } else {\n      message += `Since ${secondIdxVal} <= ${firstIdxVal}, swap is set to false and iteration continues`;\n    }\n    return message;\n}\nif (idx === 0) {\n  return;\n}\n};\n","/**\n * Generates the step by step template Radix Sort.\n *\n * @method\n * @memberOf StepByStepTemplate\n * @param {any[]} animationArr An array that contains all the animation steps.\n * @param {number} idx Index of the current animation step.\n * @returns {string} The information regarding the current step of the animation.\n */\nexport const radixSortStepByStep = (animationArr, idx) => {\n  if (idx >= animationArr.length) {\n    return 'Array is sorted';\n  }\n  if (idx > 0 && idx < animationArr.length) {\n    const currentAnimation = animationArr[idx - 1];\n    const height = currentAnimation.height;\n    const location = currentAnimation.location;\n\n    if (currentAnimation.isDistributing) {\n      return `Put element ${height} at the end of bucket ${location}`;\n    } else {\n      return `Restore the first element (${height}) in bucket ${location} back to array`;\n    }\n}\nif (idx === 0) {\n  return;\n}\n};\n","import { genericSwapStepByStep } from './genericSwapStepByStep';\nimport { selectionSortStepByStep } from './selectionSortStepByStep';\nimport { mergeSortStepByStep } from './mergeSortStepByStep';\nimport { quickSortStepByStep } from './quickSortStepByStep';\nimport { countingSortStepByStep } from './countingSortStepByStep';\nimport { radixSortStepByStep } from './radixSortStepByStep';\nimport { bucketSortStepByStep } from './bucketSortStepByStep';\nimport { heapSortStepByStep } from './heapSortStepByStep';\n\n/**\n * An Object component that is used to access the sorting method step by step template.\n *\n * @namespace StepByStepTemplate\n * @type {Object}\n */\nconst SortingAlgorithmsStepByStep = {\n  'Insertion Sort': genericSwapStepByStep,\n  'Bubble Sort': genericSwapStepByStep,\n  'Selection Sort': selectionSortStepByStep,\n  'Merge Sort': mergeSortStepByStep,\n  'Quick Sort': quickSortStepByStep,\n  'Counting Sort': countingSortStepByStep,\n  'Shell Sort': genericSwapStepByStep,\n  'Radix Sort': radixSortStepByStep,\n  'Bucket Sort': bucketSortStepByStep,\n  'Heap Sort': heapSortStepByStep,\n};\n\nexport default SortingAlgorithmsStepByStep;\n","/**\n * Generates the step by step template for Selection Sort.\n *\n * @method\n * @memberOf StepByStepTemplate\n * @param {any[]} animationArr An array that contains all the animation steps.\n * @param {number} idx Index of the current animation step.\n * @param {Object[]} referenceArray An array containing the data which is being sorted.\n * @returns {string} The information regarding the current step of the animation.\n */\nexport const selectionSortStepByStep = (animationArr, idx, referenceArray) => {\n  if (idx >= animationArr.length) {\n    return 'Array is sorted';\n  }\n\n  if (idx > 0 && idx < animationArr.length) {\n    let animationArrSwapIdx = animationArr[idx - 1];\n    let firstIdx = animationArrSwapIdx[0];\n    let secondIdx = animationArrSwapIdx[1];\n    let isSwap = animationArrSwapIdx[2];\n    let firstIdxVal = referenceArray[firstIdx].height;\n    let secondIdxVal = referenceArray[secondIdx].height;\n    let isSmaller = secondIdxVal < firstIdxVal;\n\n    if (isSwap) {\n      if (firstIdxVal === secondIdxVal) {\n        return `Since the smallest value is still ${firstIdxVal}. There is no change in position`;\n      }\n      return `The smallest value so far is ${secondIdxVal}. We swap it to index ${secondIdx}`;\n    }\n\n    // Comparisons\n    let message = `Check if ${secondIdxVal} is smaller than the smallest value so far: ${firstIdxVal}\\n`;\n    if (isSmaller) {\n      message += `Since ${secondIdxVal} is smaller than ${firstIdxVal}, smallest value is set to ${secondIdxVal}`;\n    } else {\n      message += `Since ${secondIdxVal} is not smaller than ${firstIdxVal}, no change to smallest value`;\n    }\n    return message;\n}\nif (idx === 0) {\n  return;\n}\n};\n","import { findIndexToUseInMergeSort } from '../../sortingvisualizer/util/MergeSortUtil';\nimport { arrayCopy } from '../../sortingvisualizer/util/ArrayUtil';\n\n/**\n * Generates the step by step template for Merge Sort.\n *\n * @method\n * @memberOf StepByStepTemplate\n * @param {any[]} animationArr An array that contains all the animation steps.\n * @param {number} idx Index of the current animation step.\n * @param {Object[]} referenceArray An array containing the data which is being sorted.\n * @returns {string} The information regarding the current step of the animation.\n */\nexport const mergeSortStepByStep = (animationArr, idx, referenceArray) => {\n  if (idx >= animationArr.length) {\n    return 'Array is sorted';\n\n  } \n  if (idx > 0 && idx < animationArr.length) {\n    let animationArrSwapIdx = animationArr[idx - 1];\n    let isShift = animationArrSwapIdx[2];\n    let newTempArr = arrayCopy(referenceArray);\n    let iIdx = animationArrSwapIdx[0];\n    let jIdx = animationArrSwapIdx[1];\n    let idxToUse = findIndexToUseInMergeSort(newTempArr, iIdx, jIdx);\n    if (isShift) {\n      // explaining the moving downwards and comparison\n      // this is slightly inefficient but since we are dealing with small data, it should be fine\n      let message = 'Currently in merge process: ';\n      for (let values of referenceArray) {\n        if (values.isShift) {\n          message += values.height + ', ';\n        }\n      }\n      return message.slice(0, -1);\n    }\n    // shifting back up to correct position\n    let min = referenceArray[idxToUse].height;\n    let message = `Since the minimum is ${min}, we move ${min} up\\nCurrently left in the merge process: `;\n    for (let values of referenceArray) {\n      if (values.isShift) {\n        message += values.height + ', ';\n      }\n    }\n    message = message.slice(0, -1);\n    return message;\n  }\n  if (idx === 0) {\n    return;\n  }\n};\n","/**\n * Generates the step by step template for Quick Sort.\n *\n * @method\n * @memberOf StepByStepTemplate\n * @param {any[]} animationArr An array that contains all the animation steps.\n * @param {number} idx Index of the current animation step.\n * @param {Object[]} referenceArray An array containing the data which is being sorted.\n * @returns {string} The information regarding the current step of the animation.\n */\nexport const quickSortStepByStep = (animationArr, idx, referenceArray) => {\n  if (idx >= animationArr.length) {\n    return 'Array is sorted';\n  }\n\n  if (idx > 0 && idx < animationArr.length) {\n    let animationArrSwapIdx = animationArr[idx - 1];\n    let firstIdx = animationArrSwapIdx[0];\n    let secondIdx = animationArrSwapIdx[1];\n    let isSwap = animationArrSwapIdx[2];\n    let firstIdxVal = referenceArray[firstIdx].height;\n    let secondIdxVal = referenceArray[secondIdx].height;\n    let pivotIdx = animationArrSwapIdx[3];\n    let pivotIdxVal = referenceArray[pivotIdx].height;\n    let command = animationArrSwapIdx[4];\n    let indexOfSmallerElement = animationArrSwapIdx[5];\n\n    // when a swap occurs, it is either swapping two element while iterating, else, it is swapping\n    // the pivot to its position\n    let incJ = ` Now we increment the loop variable from ${secondIdx} to ${secondIdx + 1}.`;\n    let incI = `we increment the index of the smaller element from ${indexOfSmallerElement} to ${\n      indexOfSmallerElement + 1\n    }.`;\n    if (isSwap) {\n      if (command === 'iToJ') {\n        return (\n          `Since swap is true, we swap index of the smaller element, ${indexOfSmallerElement} with` +\n          ` value ${firstIdxVal}, with loop variable index ${secondIdx}, ` +\n          `with value ${secondIdxVal}.` +\n          incJ\n        );\n      }\n      return (\n        `Since we finish one iteration, we swap the pivot to next of index of smallest` +\n        `element ${firstIdx}`\n      );\n    }\n    // Comparison to determine if to increment both loop variable or just one\n    let comparisonStatement;\n    let swapStatement;\n    if (command === 'incI') {\n      comparisonStatement = `Since ${secondIdxVal} < pivot value ${pivotIdxVal}, `;\n      // if both index are the same, no need to set swap to true\n      if (secondIdx !== indexOfSmallerElement + 1) {\n        swapStatement = ` Since index of smaller element ${\n          indexOfSmallerElement + 1\n        } not equal to index of loop variable ${secondIdx}, Swap is set to true.`;\n      } else {\n        swapStatement = ` Since index of smaller element ${\n          indexOfSmallerElement + 1\n        } equal to index of loop variable ${secondIdx}, Swap is set to false.`;\n        swapStatement += incJ;\n      }\n      return comparisonStatement + incI + swapStatement;\n    }\n\n    comparisonStatement = `Since ${secondIdxVal} >= pivot value ${pivotIdxVal}, `;\n    swapStatement = `Swap is set to false`;\n    return comparisonStatement + swapStatement + incJ;\n}\nif (idx === 0) {\n  return;\n}\n};\n","/**\n * Generates the step by step template for Counting Sort.\n *\n * @method\n * @memberOf StepByStepTemplate\n * @param {any[]} animationArr An array that contains all the animation steps.\n * @param {number} idx Index of the current animation step.\n * @param {Object[]} referenceArray An array containing the data which is being sorted.\n * @returns {string} The information regarding the current step of the animation.\n */\nexport const countingSortStepByStep = (animationArr, idx, referenceArray) => {\n  if (idx >= animationArr.length) {\n    return 'Array is sorted';\n  }\n  if (idx > 0 && idx < animationArr.length) {\n    const height = animationArr[idx - 1].height;\n\n    if (idx > referenceArray.length) {\n      return `Restore element ${height} and decrease count of ${height} by 1`;\n    } else {\n      return `Increase count of ${animationArr[idx - 1].height} by 1`;\n    }\n}\nif (idx === 0) {\n  return;\n}\n};\n","import { radixSortStepByStep } from './radixSortStepByStep';\nimport { genericSwapStepByStep } from './genericSwapStepByStep';\n\n/**\n * Generates the step by step template for Bucket Sort.\n *\n * @method\n * @memberOf StepByStepTemplate\n * @param {any[]} animationArr An array that contains all the animation steps.\n * @param {number} idx Index of the current animation step.\n * @param {Object[]} stackArr An array representing the buckets.\n * @returns {string} The information regarding the current step of the animation.\n */\nexport const bucketSortStepByStep = (animationArr, idx, stackArr) => {\n  if (idx >= animationArr.length) {\n    return 'Array is sorted';\n  }\n  if (idx > 0 && idx < animationArr.length) {\n    const currentAnimation = animationArr[idx - 1];\n\n    // Insertion sort taking place in bucket\n    if (currentAnimation.length === 4) {\n      const location = currentAnimation[3];\n      return genericSwapStepByStep(animationArr, idx, stackArr[location].array);\n    }\n\n    if (currentAnimation.isSort === undefined) {\n      return radixSortStepByStep(animationArr, idx);\n    }\n\n    // Signal start of sorting bucket\n    if (currentAnimation.isSort) {\n      return `Currently sorting bucket ${currentAnimation.location}`;\n    } else {\n      return `Bucket ${currentAnimation.location} has been sorted!`;\n    }\n}\nif (idx === 0) {\n  return;\n}\n};\n","/**\n * Generates the step by step template for Heap Sort.\n *\n * @method\n * @memberOf StepByStepTemplate\n * @param {any[]} animationArr An array that contains all the animation steps.\n * @param {number} idx Index of the current animation step.\n * @param {Object[]} referenceArray An array containing the data which is being sorted.\n * @returns {string} The information regarding the current step of the animation.\n */\nexport const heapSortStepByStep = (animationArr, idx, referenceArray) => {\n  if (idx >= animationArr.length) {\n    return 'Array is sorted';\n  }\n\n  if (idx > 0 && idx < animationArr.length) {\n    let animationArrSwapIdx = animationArr[idx - 1];\n    let firstIdx = animationArrSwapIdx[0];\n    let secondIdx = animationArrSwapIdx[1];\n    let isSwap = animationArrSwapIdx[2];\n    let heapStep = animationArrSwapIdx[3];\n    let firstIdxVal = referenceArray[firstIdx].height;\n    let secondIdxVal = referenceArray[secondIdx].height;\n    let isBigger = secondIdxVal > firstIdxVal;\n\n    if (heapStep) {\n      return `Swap the largest item in the heap, ${firstIdxVal}, with the \n      leaf node with the largest index, ${secondIdxVal}`;\n    }\n\n    if (isSwap) {\n      return `Since swap is true, swap ${secondIdxVal} and ${firstIdxVal}`;\n    }\n\n    // Comparisons message\n    let message = `Check if ${firstIdxVal} is larger than its child nodes:\\n`;\n\n    if (isBigger) {\n      message += `Since ${secondIdxVal} > ${firstIdxVal}, swap is set to true`;\n    } else {\n      message += `Since ${firstIdxVal} is larger than its child nodes, swap is set \n      to false and iteration continues`;\n    }\n    return message;\n}\nif (idx === 0) {\n  return;\n}\n};\n","import SortingAlgorithmsStepByStep from '../../../algorithm/stepbysteptemplate/allSortsStepByStep';\nimport { isBucketSort } from '../../util/GeneralUtil';\n\n/**\n * Gets the step by step text to display to the user.\n *\n * @method\n * @category StepTracingUtil\n * @param {string} visualizerAlgorithm The current algorithm of the visualizer.\n * @param {any[]} animationArr Animation array.\n * @param {number} idx Index of animation.\n * @param {Object[]} referenceArray Reference array of blocks displayed.\n * @param {Object[]} stackArr Stack array, present only in bucket and radix sort.\n * @returns {string} Step by step text generated.\n */\nexport const getStepByStepText = (\n  visualizerAlgorithm,\n  animationArr,\n  idx,\n  referenceArray,\n  stackArr\n) => {\n  const sortAlgoStepByStep = SortingAlgorithmsStepByStep[visualizerAlgorithm];\n  if (isBucketSort(visualizerAlgorithm)) {\n    return sortAlgoStepByStep(animationArr, idx, stackArr);\n  }\n  return sortAlgoStepByStep(animationArr, idx, referenceArray);\n};\n","import React, { useContext } from 'react';\nimport './styles.css';\nimport { VisualizerStateContext } from '../../Visualizer';\nimport { getStepByStepText } from './StepByStepUtil';\n\n/**\n * A component which display each steps of the sorting algorithm.\n *\n * @component\n * @category Visualizer\n */\nconst StepByStep = () => {\n  const {\n    animationArr,\n    idx,\n    referenceArray,\n    visualizerAlgorithm,\n    animationPercentage,\n    stackArr,\n  } = useContext(VisualizerStateContext);\n\n  return (\n    <div className=\"step-by-step-holder\">\n      <p>\n        {animationPercentage > 0 &&\n          getStepByStepText(visualizerAlgorithm, animationArr, idx, referenceArray, stackArr)}\n      </p>\n    </div>\n  );\n};\n\nexport default StepByStep;\n","import React, { useContext } from 'react';\nimport { AiOutlineLeft } from 'react-icons/ai';\nimport { IconContext } from 'react-icons';\nimport { VisualizerStateContext } from '../../../Visualizer';\nimport './styles.css';\nimport { resetArray } from '../../../util/ArrayUtil';\n\n/**\n * A button which executes one step in reverse for the sorting animation.\n *\n * @component\n * @category Button\n */\nconst BackButton = () => {\n  const {\n    isPlay,\n    animationPercentage,\n    executeBackwardAnimation,\n    idx,\n    arrayData,\n    setArrayData,\n    setIsReset,\n    visualizerAlgorithm,\n  } = useContext(VisualizerStateContext);\n\n  const isEmpty = animationPercentage === 0;\n\n  /**\n   * Event handler to trigger the backward animation.\n   */\n  const handleBackButtonClick = () => {\n    executeBackwardAnimation();\n    // this is to check if we are at the start animation, to reset the color of the block\n    if (idx - 1 <= 0) {\n      setArrayData(resetArray(visualizerAlgorithm, arrayData));\n      setIsReset(true);\n    }\n  };\n\n  return (\n    <button\n      className=\"forward-back-button-holder\"\n      style={{\n        transform: 'translateX(-10px)',\n        cursor: isEmpty ? '' : isPlay ? 'not-allowed' : 'pointer',\n      }}\n      onClick={() => (isPlay ? () => {} : handleBackButtonClick())}\n    >\n      <IconContext.Provider\n        value={{\n          className: 'forward-back-button',\n          style: { color: isEmpty ? 'white' : '#8789B5' },\n        }}\n      >\n        <AiOutlineLeft />\n      </IconContext.Provider>\n    </button>\n  );\n};\n\nexport default BackButton;\n","import React from 'react';\nimport { IconContext } from 'react-icons';\nimport { AiFillCaretRight, AiOutlinePause, AiOutlineReload } from 'react-icons/ai';\nimport './styles.css';\n\n/**\n * Depending on the {@code type}, it will show the relevant button state.\n *\n * @component\n * @category Button\n * @param {string} type The state of the button to be shown: 'play', 'pause', 'replay'.\n */\nconst PlayPauseReplayButton = ({ type }) => {\n  return (\n    <IconContext.Provider\n      value={{\n        className: 'three-state-button',\n        style: { transform: type === 'play' ? 'translateX(3px)' : 'translateX(0px)' },\n      }}\n    >\n      {type === 'play' ? (\n        <AiFillCaretRight />\n      ) : type === 'pause' ? (\n        <AiOutlinePause />\n      ) : (\n        <AiOutlineReload />\n      )}\n    </IconContext.Provider>\n  );\n};\n\nexport default PlayPauseReplayButton;\n","import React, { useContext } from 'react';\nimport { VisualizerStateContext } from '../../../Visualizer';\nimport PlayPauseReplayButton from './PlayPauseReplayButton';\nimport './styles.css';\n\n/**\n * A component which holds the 3 states, Play, Pause, Replay.\n *\n * @component\n * @category Button\n */\nconst ThreeStateButton = () => {\n  const {\n    isPlay,\n    isReplay,\n    setIsReplay,\n    setIsPlay,\n    setIsInMidstOfSort,\n    setAnimationPercentage,\n    setIsReset,\n  } = useContext(VisualizerStateContext);\n\n  /**\n   * Event handler that trigger play, pause, replay functionality.\n   */\n  const handleThreeStateButtonClick = () => {\n    if (isReplay) {\n      setIsReplay(false);\n      setAnimationPercentage(0);\n      setIsReset(true);\n      setTimeout(() => setIsPlay(true), 300);\n    } else {\n      setIsPlay(!isPlay);\n    }\n    setIsInMidstOfSort(true);\n  };\n\n  return (\n    <button className=\"three-state-button-holder\" onClick={() => handleThreeStateButtonClick()}>\n      {isReplay ? (\n        <PlayPauseReplayButton type=\"replay\" />\n      ) : isPlay ? (\n        <PlayPauseReplayButton type=\"pause\" />\n      ) : (\n        <PlayPauseReplayButton type=\"play\" />\n      )}\n    </button>\n  );\n};\n\nexport default ThreeStateButton;\n","import React, { useContext } from 'react';\nimport './styles.css';\nimport { VisualizerStateContext } from '../../../Visualizer';\nimport { buckets } from '../../../util/CountingSortUtil';\nimport { stack } from '../../../util/RadixSortUtil';\nimport { arrayCopy, generateArray } from '../../../util/ArrayUtil';\n\n/**\n * A button to generate new data for the \"blocks\" for the sorting animation.\n *\n * @component\n * @category Button\n */\nconst NewDataButton = () => {\n  const {\n    isPlay,\n    dataSize,\n    setArrayData,\n    setIsInMidstOfSort,\n    setIsReplay,\n    setAnimationPercentage,\n    visualizerAlgorithm,\n    setCountArr,\n    setStackArr,\n    setIsReset,\n    setHistoryArr,\n  } = useContext(VisualizerStateContext);\n\n  /**\n   * Event handler to generate new data set for the sorting animation.\n   */\n  const handleNewDataButtonClick = () => {\n    if (!isPlay) {\n      setArrayData(generateArray(dataSize, visualizerAlgorithm));\n      setIsInMidstOfSort(false);\n      setAnimationPercentage(0);\n      setIsReplay(false);\n      setCountArr(arrayCopy(buckets));\n      setStackArr(arrayCopy(stack));\n      setHistoryArr([]);\n      setIsReset(true);\n    }\n  };\n\n  return (\n    <div className=\"new-data-box\" style={{ cursor: isPlay ? 'not-allowed' : 'pointer' }}>\n      <span onClick={() => handleNewDataButtonClick()}>New Data</span>\n    </div>\n  );\n};\n\nexport default NewDataButton;\n","import React, { useContext } from 'react';\nimport { IconContext } from 'react-icons';\nimport { AiOutlineRight } from 'react-icons/ai';\nimport './styles.css';\nimport { VisualizerStateContext } from '../../../Visualizer';\n\n/**\n * A button which executes one step forward for the sorting animation.\n *\n * @component\n * @category Button\n */\nconst ForwardButton = () => {\n  const { isPlay, animationPercentage, executeForwardAnimation, idx, animationArr } = useContext(\n    VisualizerStateContext\n  );\n\n  const isFull = animationPercentage === 100;\n\n  /**\n   * Event handler to trigger the forward animation.\n   */\n  const handleForwardButtonClick = () => {\n    if (idx < animationArr.length) {\n      executeForwardAnimation();\n    }\n  };\n\n  return (\n    <button\n      className=\"forward-back-button-holder\"\n      style={{\n        transform: 'translateX(10px)',\n        cursor: isFull ? '' : isPlay ? 'not-allowed' : 'pointer',\n      }}\n      onClick={isPlay ? () => {} : () => handleForwardButtonClick()}\n    >\n      <IconContext.Provider\n        value={{\n          className: 'forward-back-button',\n          style: { color: isFull ? 'white' : '#8789B5' },\n        }}\n      >\n        <AiOutlineRight />\n      </IconContext.Provider>\n    </button>\n  );\n};\n\nexport default ForwardButton;\n","import BackButton from './forwardbackbutton/BackButton';\nimport ThreeStateButton from './threestatebutton/ThreeStateButton';\nimport NewDataButton from './newdatabutton/NewDataButton';\nimport ForwardButton from './forwardbackbutton/ForwardButton';\nimport React from 'react';\nimport './styles.css';\n\n/**\n * A component which holds forward and backward button, as well as the play, pause and replay button.\n *\n * @component\n * @category Visualizer\n */\nconst ButtonBox = () => (\n  <div className=\"button-box\">\n    <BackButton />\n    <div className=\"play-reset-button-box\">\n      <ThreeStateButton />\n      <NewDataButton />\n    </div>\n    <ForwardButton />\n  </div>\n);\n\nexport default ButtonBox;\n","import BubbleSort from './bubbleSortEx';\nimport InsertionSort from './insertionSortEx';\nimport QuickSort from './quickSortEx';\nimport RadixSort from './radixSortEx';\nimport BucketSort from './bucketSortEx';\nimport CountingSort from './countingSortEx';\nimport SelectionSort from './selectionSortEx';\nimport MergeSort from './mergeSortEx';\nimport ShellSort from './shellSortEx';\nimport HeapSort from './heapSortEx';\n\n/**\n * Contains all the explanations for the sorting algorithms.\n *\n * @namespace Explanations\n * @type {Object}\n */\nconst explanations = {\n  'Bubble Sort': BubbleSort,\n  'Insertion Sort': InsertionSort,\n  'Quick Sort': QuickSort,\n  'Radix Sort': RadixSort,\n  'Bucket Sort': BucketSort,\n  'Counting Sort': CountingSort,\n  'Selection Sort': SelectionSort,\n  'Merge Sort': MergeSort,\n  'Shell Sort': ShellSort,\n  'Heap Sort': HeapSort,\n};\n\nexport default explanations;\n","/**\n * Bubble sort algorithm details.\n *\n * @memberOf Explanations\n * @see {@link https://www.geeksforgeeks.org/bubble-sort/|Geeks for Geeks}\n * @const {\n * {bestTime: string,\n * worstSpace: string,\n * additionalDesc: string,\n * averageTime: JSX.Element,\n * stable: boolean,\n * name: string,\n * worstTime: JSX.Element,\n * link: string,\n * description: string,\n * inPlace: boolean}\n * }\n */\nconst BubbleSort = {\n  name: 'Bubble',\n  description:\n    'Bubble Sort is the simplest sorting algorithm that works by ' +\n    'repeatedly swapping adjacent elements if they are in the wrong order. ' +\n    'This procedure is repeated until no swaps are required, indicating ' +\n    'that the list has been sorted.',\n  additionalDesc: '',\n  worstTime: (\n    <span>\n      N<sup>2</sup>\n    </span>\n  ),\n  averageTime: (\n    <span>\n      N<sup>2</sup>\n    </span>\n  ),\n  bestTime: 'N',\n  worstSpace: '1',\n  stable: true,\n  inPlace: true,\n  link: 'https://www.geeksforgeeks.org/bubble-sort/',\n};\n\nexport default BubbleSort;\n","/**\n * Insertion sort algorithm details.\n *\n * @memberOf Explanations\n * @see {@link https://www.geeksforgeeks.org/insertion-sort/|Geeks for Geeks}\n * @const {\n * {bestTime: string,\n * worstSpace: string,\n * additionalDesc: string,\n * averageTime: JSX.Element,\n * stable: boolean,\n * name: string,\n * worstTime: JSX.Element,\n * link: string,\n * description: string,\n * inPlace: boolean}\n * }\n */\nconst InsertionSort = {\n  name: 'Insertion',\n  description:\n    'Insertion Sort is a simple sorting algorithm that builds the final ' +\n    'sorted list one item at a time. The list is virtually split ' +\n    'into a sorted and an unsorted part. Values from the unsorted part are ' +\n    'picked and placed at the correct position in the sorted part.',\n  additionalDesc: '',\n  worstTime: (\n    <span>\n      N<sup>2</sup>\n    </span>\n  ),\n  averageTime: (\n    <span>\n      N<sup>2</sup>\n    </span>\n  ),\n  bestTime: 'N',\n  worstSpace: '1',\n  stable: true,\n  inPlace: true,\n  link: 'https://www.geeksforgeeks.org/insertion-sort/',\n};\n\nexport default InsertionSort;\n","/**\n * Quick sort algorithm details.\n *\n * @memberOf Explanations\n * @see {@link https://www.geeksforgeeks.org/quick-sort/|Geeks for Geeks}\n * @const {\n * {bestTime: string,\n * worstSpace: string,\n * additionalDesc: string,\n * averageTime: string,\n * stable: boolean,\n * name: string,\n * worstTime: JSX.Element,\n * link: string,\n * description: string,\n * inPlace: boolean}\n * }\n */\nconst QuickSort = {\n  name: 'Quick',\n  description:\n    'Quick Sort is a Divide and Conquer algorithm. It picks an element as pivot and partitions ' +\n    'the given array around the picked pivot. There are many different versions of Quick Sort that ' +\n    'pick pivot in different ways.',\n  additionalDesc: '',\n  worstTime: (\n    <span>\n      N<sup>2</sup>\n    </span>\n  ),\n  averageTime: 'NlogN',\n  bestTime: 'N',\n  worstSpace: 'N',\n  stable: false,\n  inPlace: true,\n  link: 'https://www.geeksforgeeks.org/quick-sort/',\n};\n\nexport default QuickSort;\n","/**\n * Radix sort algorithm details.\n *\n * @memberOf Explanations\n * @see {@link https://www.programiz.com/dsa/radix-sort|Programiz}\n * @const {\n * {bestTime: string,\n * worstSpace: string,\n * additionalDesc: string,\n * averageTime: string,\n * stable: boolean,\n * name: string,\n * worstTime: string,\n * link: string,\n * description: string,\n * inPlace: boolean}\n * }\n */\nconst RadixSort = {\n  name: 'Radix',\n  description:\n    'Radix sort works by sorting each digit from least significant digit to most significant ' +\n    \"digit. So in base 10 (the decimal system), radix sort would sort by the digits in the 1's \" +\n    'place, then the 10’s place, and so on. To do this, radix sort uses counting sort as a ' +\n    'subroutine to sort the digits in each place value.',\n  additionalDesc:\n    'd is the number of digits in the input numbers, b is the base for representing numbers,',\n  worstTime: 'd(n + b)',\n  averageTime: 'd(n + b)',\n  bestTime: 'd(n + b)',\n  worstSpace: 'n + b',\n  stable: true,\n  inPlace: false,\n  link: 'https://www.programiz.com/dsa/radix-sort',\n};\n\nexport default RadixSort;\n","/**\n * Bucket sort algorithm details.\n * Explanation adapted from CLRS Introduction to Algorithms textbook.\n *\n * @memberOf Explanations\n * @const {\n * {bestTime: string,\n * worstSpace: string,\n * additionalDesc: string,\n * averageTime: string,\n * stable: boolean,\n * name: string,\n * worstTime: JSX.Element,\n * link: string,\n * description: string,\n * inPlace: boolean}\n * }\n */\nconst BucketSort = {\n  name: 'Bucket',\n  description:\n    'Bucket sort assumes that the input is drawn from a uniform distribution of [0, 1). ' +\n    'The interval [0, 1) is divided into n equal-sized sub-intervals (buckets). Then, the input ' +\n    'array is distributed into these buckets. To produce ' +\n    'the output, we simply sort the numbers in each bucket and then go through the buckets in ' +\n    'order to list the elements.',\n  additionalDesc: '',\n  worstTime: (\n    <span>\n      N<sup>2</sup>\n    </span>\n  ),\n  averageTime: 'N',\n  bestTime: 'N',\n  worstSpace: 'N',\n  stable: true,\n  inPlace: false,\n  link: 'https://www.geeksforgeeks.org/bucket-sort-2/',\n};\n\nexport default BucketSort;\n","/**\n * Counting sort algorithm details.\n *\n * @memberOf Explanations\n * @see {@link https://www.geeksforgeeks.org/counting-sort/|Geeks for Geeks}\n * @const {\n * {bestTime: string,\n * worstSpace: string,\n * additionalDesc: string,\n * averageTime: string,\n * stable: boolean,\n * name: string,\n * worstTime: string,\n * link: string,\n * description: string,\n * inPlace: boolean}\n * }\n */\nconst CountingSort = {\n  name: 'Counting',\n  description:\n    'Counting sort is a sorting technique based on keys between a specific range. It works by ' +\n    'counting the number of objects having distinct key values (kind of hashing), and using ' +\n    'arithmetic on those counts to determine the positions of each key value in the output ' +\n    'sequence.',\n  additionalDesc: 'k is the range of the key values,',\n  worstTime: 'N + k',\n  averageTime: 'N + k',\n  bestTime: 'N + k',\n  worstSpace: 'N + k',\n  stable: true,\n  inPlace: false,\n  link: 'https://www.geeksforgeeks.org/counting-sort/',\n};\n\nexport default CountingSort;\n","/**\n * Selection sort algorithm details.\n *\n * @memberOf Explanations\n * @see {@link https://www.geeksforgeeks.org/selection-sort/|Geeks for Geeks}\n * @const {\n * {bestTime: JSX.Element,\n * worstSpace: string,\n * additionalDesc: string,\n * averageTime: JSX.Element,\n * stable: boolean,\n * name: string,\n * worstTime: JSX.Element,\n * link: string,\n * description: string,\n * inPlace: boolean}\n * }\n */\nconst SelectionSort = {\n  name: 'Selection',\n  description:\n    'Selection Sort algorithm sorts an array by repeatedly finding the minimum element ' +\n    '(considering ascending order) from unsorted part and putting it at the beginning. The ' +\n    'algorithm maintains two subarrays, a subarray which is sorted and the remaining array which' +\n    ' is unsorted',\n  additionalDesc: '',\n  worstTime: (\n    <span>\n      N<sup>2</sup>\n    </span>\n  ),\n  averageTime: (\n    <span>\n      N<sup>2</sup>\n    </span>\n  ),\n  bestTime: (\n    <span>\n      N<sup>2</sup>\n    </span>\n  ),\n  worstSpace: '1',\n  stable: false,\n  inPlace: true,\n  link: 'https://www.geeksforgeeks.org/selection-sort/',\n};\n\nexport default SelectionSort;\n","/**\n * Merge sort algorithm details.\n *\n * @memberOf Explanations\n * @see {@link https://www.geeksforgeeks.org/merge-sort/|Geeks for Geeks}\n * @const {\n * {bestTime: string,\n * worstSpace: string,\n * additionalDesc: string,\n * averageTime: string,\n * stable: boolean,\n * name: string,\n * worstTime: string,\n * link: string,\n * description: string,\n * inPlace: boolean}\n * }\n */\nconst MergeSort = {\n  name: 'Merge',\n  description:\n    'Merge Sort is a Divide and Conquer algorithm. It divides the input array into two halves, ' +\n    'calls itself for the two halves, and then merges the two sorted halves. The merge() function ' +\n    'is used for merging two halves. The merge(arr, l, m, r) is a key process that assumes that ' +\n    'arr[l..m] and arr[m+1..r] are sorted and merges the two sorted subarrays into one',\n  additionalDesc: '',\n  worstTime: 'NlogN',\n  averageTime: 'NlogN',\n  bestTime: 'NlogN',\n  worstSpace: 'N',\n  stable: true,\n  inPlace: false,\n  link: 'https://www.geeksforgeeks.org/merge-sort/',\n};\n\nexport default MergeSort;\n","/**\n * Shell sort algorithm details.\n *\n * @memberOf Explanations\n * @see {@link https://www.geeksforgeeks.org/shellsort/|Geeks for Geeks}\n * @const {\n * {bestTime: string,\n * worstSpace: string,\n * additionalDesc: string,\n * averageTime: string,\n * stable: boolean,\n * name: string,\n * worstTime: JSX.Element,\n * link: string,\n * description: string,\n * inPlace: boolean}\n * }\n */\nconst ShellSort = {\n  name: 'Shell',\n  description:\n    'Shell Sort is mainly a variation of Insertion Sort. The idea of Shell Sort is to allow exchange ' +\n    'of items far apart from each other, then progressively reducing the gap between elements ' +\n    'to be compared. In the last iteration of Shell Sort where gap equals 1, regular Insertion Sort ' +\n    'is performed on the resultant array.',\n  additionalDesc: '',\n  worstTime: (\n    <span>\n      N<sup>2</sup>\n    </span>\n  ),\n  averageTime: 'NlogN',\n  bestTime: 'NlogN',\n  worstSpace: '1',\n  stable: false,\n  inPlace: true,\n  link: 'https://www.geeksforgeeks.org/shellsort/',\n};\n\nexport default ShellSort;\n","/**\n * Heap sort algorithm details.\n *\n * @memberOf Explanations\n * @see {@link https://www.geeksforgeeks.org/heap-sort/|Geeks for Geeks}\n * @const {\n * {bestTime: string,\n * worstSpace: string,\n * additionalDesc: string,\n * averageTime: string,\n * stable: boolean,\n * name: string,\n * worstTime: string,\n * link: string,\n * description: string,\n * inPlace: boolean}\n * }\n */\nconst HeapSort = {\n  name: 'Heap',\n  description:\n    'Heap Sort is a comparison based sorting technique based on Binary Heap data structure.' +\n    ' It is similar to selection sort where we first find the maximum element and place the' +\n    ' maximum element at the end. We repeat the same process for the remaining elements.',\n  additionalDesc: '',\n  worstTime: 'NlogN',\n  averageTime: 'NlogN',\n  bestTime: 'NlogN',\n  worstSpace: '1',\n  stable: false,\n  inPlace: true,\n  link: 'https://www.geeksforgeeks.org/heap-sort/',\n};\n\nexport default HeapSort;\n","import { FaCheckCircle, FaTimesCircle } from 'react-icons/fa';\nimport React from 'react';\nimport './styles.css';\n\n/**\n * Performance section detailing the performance of the current sorting algorithm.\n *\n * @component\n * @category CodeExplanation\n * @returns {JSX.Element} Performance section component.\n */\nconst PerformanceSection = ({ sortDetails }) => {\n  /**\n   * Complexities terminologies used.\n   *\n   * @returns {JSX.Element} List of complexities component.\n   */\n  const ListOfComplexities = () => (\n    <div className=\"text\">\n      <p>Worst time complexity</p>\n      <p>Average time complexity</p>\n      <p>Best time complexity</p>\n      <p>Worst space complexity</p>\n    </div>\n  );\n\n  /**\n   * Complexities of the sorting algorithm.\n   *\n   * @returns {JSX.Element} Complexity component describing the complexities of the sorting\n   * algorithm.\n   */\n  const Complexity = () => (\n    <div className=\"complexity\">\n      <p>O({sortDetails.worstTime})</p>\n      <p>θ({sortDetails.averageTime})</p>\n      <p>Ω({sortDetails.bestTime})</p>\n      <p>O({sortDetails.worstSpace})</p>\n    </div>\n  );\n\n  /**\n   * General type with icon template, used for detailing whether the sorting algorithm used is\n   * stable and in-place.\n   *\n   * @param {string} type Input type.\n   * @param {boolean} isTick detailing whether the type is true or false.\n   * @returns {JSX.Element} Type with icon component.\n   */\n  const TypeWithIcon = ({ type, isTick }) => {\n    /**\n     * Icon type which describes whether the boolean is true or false. Returns the Tick symbol\n     * if boolean is true, otherwise it returns the Cross symbol.\n     *\n     * @returns {JSX.Element} IconType.\n     */\n    const IconType = () => {\n      return isTick ? (\n        <FaCheckCircle size=\"25\" color=\"#11C2C9\" />\n      ) : (\n        <FaTimesCircle size=\"25\" color=\"#FF4E4E\" />\n      );\n    };\n\n    return (\n      <div className=\"typeWithIcon\">\n        <p>{type}</p>\n        <IconType />\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"performance\">\n      <p className=\"explanation-para\">\n        {`Assuming N is the size of array, ` + sortDetails.additionalDesc}\n      </p>\n      <div className=\"row-container-one\">\n        <ListOfComplexities />\n        <Complexity />\n      </div>\n      <div className=\"row-container-two\">\n        <TypeWithIcon type={'Stable'} isTick={sortDetails.stable} />\n        <TypeWithIcon type={'In-place'} isTick={sortDetails.inPlace} />\n      </div>\n    </div>\n  );\n};\n\nexport default PerformanceSection;\n","import React, { useEffect, useState } from 'react';\nimport './styles.css';\nimport explanations from '../explanations/Explanations';\nimport PerformanceSection from './PerformanceSection';\n\n/**\n * CodeExplanation component which encapsulates the details for how the sorting algorithm works,\n * and the performance of the algorithm.\n *\n * @component\n * @category CodeExplanation\n * @param {string} algo Current algorithm selected.\n * @returns {JSX.Element} Code explanation component.\n */\nconst CodeExplanation = ({ algo }) => {\n  // Sort details of the algorithm.\n  const [sortDetails, setSortDetails] = useState(() => explanations[algo]);\n\n  useEffect(() => {\n    setSortDetails(explanations[algo]);\n  }, [algo]);\n\n  /**\n   * First header component for the explanation section.\n   *\n   * @returns {JSX.Element} First header component for the explanation section.\n   */\n  const HeaderOne = () => <header>How {sortDetails.name} Sort works</header>;\n\n  /**\n   * Explanation component detailing how the code works.\n   *\n   * @returns {JSX.Element} Explanation component detailing how the code works.\n   */\n  const Explanation = () => <p style={{ width: `112%` }}>{sortDetails.description}</p>;\n\n  /**\n   * Second header component for the performance section.\n   *\n   * @returns {JSX.Element} Second header component for the performance section.\n   */\n  const HeaderTwo = () => <header>Performance</header>;\n\n  /**\n   * Link component which provides a link to an external website for more information about the\n   * sorting algorithm used.\n   *\n   * @returns {JSX.Element} Link component.\n   */\n  const Link = () => (\n    <a className=\"link\" target=\"_blank\" rel=\"noopener noreferrer\" href={sortDetails.link}>\n      Click for more info\n    </a>\n  );\n\n  return (\n    <div className=\"main\">\n      <HeaderOne />\n      <Explanation />\n      <HeaderTwo />\n      <PerformanceSection sortDetails={sortDetails} />\n    </div>\n  );\n};\n\nexport default CodeExplanation;\n","import BubbleSort from './bubbleSortTemplate';\nimport InsertionSort from './insertionSortTemplate';\nimport QuickSort from './quickSortTemplate';\nimport RadixSort from './radixSortTemplate';\nimport BucketSort from './bucketSortTemplate';\nimport CountingSort from './countingSortTemplate';\nimport SelectionSort from './selectionSortTemplate';\nimport MergeSort from './mergeSortTemplate';\nimport ShellSort from './shellSortTemplate';\nimport HeapSort from './heapSortTemplate';\n\n/**\n * Contains all the code templates for the sorting algorithms.\n *\n * @namespace Code templates\n * @type {Object}\n */\nconst templates = {\n  'Bubble Sort': BubbleSort,\n  'Insertion Sort': InsertionSort,\n  'Quick Sort': QuickSort,\n  'Radix Sort': RadixSort,\n  'Bucket Sort': BucketSort,\n  'Counting Sort': CountingSort,\n  'Selection Sort': SelectionSort,\n  'Merge Sort': MergeSort,\n  'Shell Sort': ShellSort,\n  'Heap Sort': HeapSort,\n};\n\nexport default templates;\n","/**\n * Bubble sort algorithm details.\n *\n * @memberOf Code templates\n * @const {{Java: string, 'C/C++': string, JavaScript: string, Python: string}}\n */\nconst BubbleSort = {\n  Java:\n    'void swap(int[] arr, int i, int j) {\\n' +\n    '    int temp = arr[i];\\n' +\n    '    arr[i] = arr[j];\\n' +\n    '    arr[j] = temp;\\n' +\n    '}\\n' +\n    '\\n' +\n    'void bubbleSort(int[] arr) {\\n' +\n    '    \\n' +\n    '    // Loop in the range of unsorted elements\\n' +\n    '    for (int i = arr.length - 1; i >= 0; i--) {\\n' +\n    '        boolean swapped = true;\\n' +\n    '        \\n' +\n    '        // Bubble largest element to the end\\n' +\n    '        for (int j = 0; j < i; j++) {\\n' +\n    '            if (arr[j] > arr[j + 1]) {\\n' +\n    '                swap(arr, j, j + 1);\\n' +\n    '                swapped = false;\\n' +\n    '            }\\n' +\n    '        }\\n' +\n    '        \\n' +\n    '        // Array is already sorted as there are no swaps in this iteration\\n' +\n    '        if (swapped) {\\n' +\n    '            break;\\n' +\n    '        }\\n' +\n    '    }\\n' +\n    '}\\n',\n  JavaScript:\n    'function bubbleSort(arr) {\\n\\n' +\n    '  // Loop in the range of unsorted elements\\n' +\n    '  for (let i = arr.length - 1; i >= 0; i--) {\\n' +\n    '    let swapped = true;\\n\\n' +\n    '    // Bubble largest element to the end\\n' +\n    '    for (let j = 0; j < i; j++) {\\n' +\n    '      if (arr[j] > arr[j + 1]) {\\n' +\n    '        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\\n' +\n    '        swapped = false;\\n' +\n    '      }\\n' +\n    '    }\\n\\n' +\n    '    // Array is already sorted as there are no swaps in this iteration\\n' +\n    '    if (swapped) {\\n' +\n    '      break;\\n' +\n    '    }\\n' +\n    '  }\\n' +\n    '}\\n',\n  Python:\n    'def bubble_sort(arr):\\n' +\n    '\\n' +\n    '    # Loop in the range of unsorted elements\\n' +\n    '    for i in range(len(arr) - 1, 0, -1):\\n' +\n    '        swapped = True\\n' +\n    '\\n' +\n    '        # Bubble largest element to the end\\n' +\n    '        for j in range(i):\\n' +\n    '            if arr[j] > arr[j + 1]:\\n' +\n    '                arr[j], arr[j + 1] = arr[j + 1], arr[j]\\n' +\n    '                swapped = False\\n' +\n    '\\n' +\n    '        # Array is already sorted as there are no swaps in this iteration\\n' +\n    '        if swapped:\\n' +\n    '            break\\n',\n  'C/C++':\n    'void swap(int *a, int *b)\\n' +\n    '{\\n' +\n    '    int temp = *a;\\n' +\n    '    *a = *b;\\n' +\n    '    *b = temp;\\n' +\n    '}\\n' +\n    '\\n' +\n    'void bubbleSort(int arr[], int len)\\n' +\n    '{\\n' +\n    '    int i, j;\\n' +\n    '    bool swapped;\\n' +\n    '\\n' +\n    '    // Loop in the range of unsorted elements\\n' +\n    '    for (i = len - 1; i >= 0; --i)\\n' +\n    '    {\\n' +\n    '        swapped = true;\\n' +\n    '\\n' +\n    '        // Bubble largest element to the end\\n' +\n    '        for (j = 0; j < i; ++j)\\n' +\n    '        {\\n' +\n    '            if (arr[j] > arr[j + 1])\\n' +\n    '            {\\n' +\n    '                swap(&arr[j], &arr[j + 1]);\\n' +\n    '                swapped = false;\\n' +\n    '            }\\n' +\n    '        }\\n' +\n    '\\n' +\n    '        // Array is already sorted as there are no swaps in this iteration\\n' +\n    '        if (swapped)\\n' +\n    '        {\\n' +\n    '            break;\\n' +\n    '        }\\n' +\n    '    }\\n' +\n    '}\\n',\n};\n\nexport default BubbleSort;\n","/**\n * Insertion sort algorithm details.\n *\n * @see {@link https://www.geeksforgeeks.org/insertion-sort/|Geeks for Geeks}\n * @memberOf Code templates\n * @const {{Java: string, 'C/C++': string, JavaScript: string, Python: string}}\n */\nconst InsertionSort = {\n  Java:\n    'void insertionSort(int[] arr) {\\n' +\n    '\\n' +\n    '    // Elements from 0 to i - 1 are sorted\\n' +\n    '    for (int i = 1; i < arr.length; i++) {\\n' +\n    '\\n' +\n    '        int key = arr[i];\\n' +\n    '        int j = i - 1;\\n' +\n    '\\n' +\n    '        // Locate position of key to insert in the sorted region\\n' +\n    '        while (j >= 0 && arr[j] > key) {\\n' +\n    '            arr[j + 1] = arr[j];\\n' +\n    '            j -= 1;\\n' +\n    '        }\\n' +\n    '        arr[j + 1] = key;\\n' +\n    '    }\\n' +\n    '}\\n',\n  JavaScript:\n    'function insertionSort(arr) {\\n' +\n    '\\n' +\n    '  // Elements from 0 to i - 1 are sorted\\n' +\n    '  for (let i = 1; i < arr.length; i++) {\\n' +\n    '      \\n' +\n    '    const key = arr[i];\\n' +\n    '    let j = i - 1;\\n' +\n    '\\n' +\n    '    // Locate position of key to insert in the sorted region\\n' +\n    '    while (j >= 0 && arr[j] > key) {\\n' +\n    '      arr[j + 1] = arr[j];\\n' +\n    '      j -= 1;\\n' +\n    '    }\\n' +\n    '    arr[j + 1] = key;\\n' +\n    '  }\\n' +\n    '}\\n',\n  Python:\n    'def insertion_sort(arr):\\n' +\n    '\\n' +\n    '    # Elements from 0 to i - 1 are sorted\\n' +\n    '    for i in range(1, len(arr)):\\n' +\n    '\\n' +\n    '        key = arr[i]\\n' +\n    '        j = i - 1\\n' +\n    '\\n' +\n    '        # Locate position of key to insert in the sorted region\\n' +\n    '        while j >= 0 and arr[j] > key:\\n' +\n    '            arr[j + 1] = arr[j]\\n' +\n    '            j -= 1\\n' +\n    '        arr[j + 1] = key\\n',\n  'C/C++':\n    'void insertionSort(int arr[], int len)\\n' +\n    '{\\n' +\n    '    // Elements from 0 to i - 1 are sorted\\n' +\n    '    for (int i = 1; i < len; i++)\\n' +\n    '    {\\n' +\n    '\\n' +\n    '        int key = arr[i];\\n' +\n    '        int j = i - 1;\\n' +\n    '\\n' +\n    '        // Locate position of key to insert in the sorted region\\n' +\n    '        while (j >= 0 && arr[j] > key)\\n' +\n    '        {\\n' +\n    '            arr[j + 1] = arr[j];\\n' +\n    '            j -= 1;\\n' +\n    '        }\\n' +\n    '        arr[j + 1] = key;\\n' +\n    '    }\\n' +\n    '}\\n',\n};\n\nexport default InsertionSort;\n","/**\n * Quick sort algorithm details.\n *\n * @see {@link https://www.geeksforgeeks.org/quick-sort/|Geeks for Geeks}\n * @memberOf Code templates\n * @const {{Java: string, 'C/C++': string, JavaScript: string, Python: string}}\n */\nconst QuickSort = {\n  Java:\n    'void swap(int[] arr, int i, int j) {\\n' +\n    '    int temp = arr[i];\\n' +\n    '    arr[i] = arr[j];\\n' +\n    '    arr[j] = temp;\\n' +\n    '}\\n' +\n    '\\n' +\n    'int partition(int[] arr, int low, int high) {\\n' +\n    '    int pivot = arr[high];\\n' +\n    '    int i = low - 1; // index of smaller element \\n' +\n    '    for (int j = low; j < high; j++) {\\n' +\n    '        // If current element is smaller than the pivot \\n' +\n    '        if (arr[j] < pivot) {\\n' +\n    '            i++;\\n' +\n    '            swap(arr, i, j);\\n' +\n    '        }\\n' +\n    '    }\\n' +\n    '    swap(arr, i + 1, high);\\n' +\n    '    return i + 1;\\n' +\n    '}\\n' +\n    '\\n' +\n    '/* The main function that implements QuickSort() \\n' +\n    '  arr[] --> Array to be sorted, \\n' +\n    '  low  --> Starting index, \\n' +\n    '  high  --> Ending index */\\n' +\n    'void quickSortHelper(int[] arr, int low, int high) {\\n' +\n    '    if (low < high) { \\n' +\n    '        /* pi is partitioning index, arr[pi] is  \\n' +\n    '           now at right place */\\n' +\n    '        int pi = partition(arr, low, high);\\n' +\n    '        // Recursively sort elements before \\n' +\n    '        // partition and after partition \\n' +\n    '        quickSortHelper(arr, low, pi - 1);\\n' +\n    '        quickSortHelper(arr, pi + 1, high);\\n' +\n    '    }\\n' +\n    '}\\n' +\n    '\\n' +\n    'void quickSort(int[] arr) {\\n' +\n    '    quickSortHelper(arr, 0, arr.length - 1);\\n' +\n    '}\\n\\n',\n  JavaScript:\n    'function partition(arr, low, high) {\\n' +\n    '  // Take last element as the pivot\\n' +\n    '  let pivot = arr[high];\\n' +\n    '  let i = low - 1;\\n' +\n    '  for (let j = low; j < high; j++) {\\n' +\n    '    // If current element is smaller than the pivot\\n' +\n    '    if (arr[j] < pivot) {\\n' +\n    '      i++;\\n' +\n    '      [arr[j], arr[i]] = [arr[i], arr[j]];\\n' +\n    '    }\\n' +\n    '  }\\n' +\n    '  // Place pivot in the correct position in the partition\\n' +\n    '  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\\n' +\n    '  return i + 1;\\n' +\n    '}\\n' +\n    '\\n' +\n    'function quickSortHelper(arr, low, high) {\\n' +\n    '  if (low < high) {\\n' +\n    '    /* pi is partitioning index, arr[pi] is  \\n' +\n    '       now at right place */\\n' +\n    '    let pi = partition(arr, low, high);\\n' +\n    '    // Recursively sort elements before \\n' +\n    '    // partition and after partition \\n' +\n    '    quickSortHelper(arr, low, pi - 1);\\n' +\n    '    quickSortHelper(arr, pi + 1, high);\\n' +\n    '  }\\n' +\n    '}\\n' +\n    '\\n' +\n    'function quickSort(arr) {\\n' +\n    '  quickSortHelper(arr, 0, arr.length - 1);\\n' +\n    '}\\n\\n',\n  Python:\n    'def partition(arr, low, high):\\n' +\n    '    i = low - 1\\n' +\n    '\\n' +\n    '    # Take last element as the pivot\\n' +\n    '    pivot = arr[high]\\n' +\n    '    for j in range(low, high):\\n' +\n    '\\n' +\n    '        # If current element is smaller than the pivot\\n' +\n    '        if arr[j] < pivot:\\n' +\n    '        i = i + 1\\n' +\n    '        arr[i], arr[j] = arr[j], arr[i]\\n' +\n    '\\n' +\n    '    # Place pivot in the correct position in the partition\\n' +\n    '    arr[i + 1], arr[high] = arr[high], arr[i + 1]\\n' +\n    '    return i + 1\\n' +\n    '\\n' +\n    '\\n' +\n    'def quick_sort_helper(arr, low, high):\\n' +\n    '    while low < high:\\n' +\n    '\\n' +\n    '        pi = partition(arr, low, high)\\n' +\n    '        # pi is partitioning index, arr[pi] is  \\n' +\n    '        # now at right place */\\n' +\n    '        if low < high:\\n' +\n    '             int pi = partition(arr, low, high)\\n' +\n    '             quick_sort_helper(arr, low, pi - 1)\\n' +\n    '             quick_sort_helper(arr, pi + 1, high)\\n' +\n    '\\n' +\n    '\\n' +\n    'def quick_sort(arr):\\n' +\n    '    quick_sort_helper(arr, 0, len(arr) - 1)\\n' +\n    '\\n\\n',\n  'C/C++':\n    'void swap(int *a, int *b)\\n' +\n    '{\\n' +\n    '    int temp = *a;\\n' +\n    '    *a = *b;\\n' +\n    '    *b = temp;\\n' +\n    '}\\n' +\n    '\\n' +\n    'int partition(int arr[], int low, int high)\\n' +\n    '{\\n' +\n    '    // Take last element as the pivot\\n' +\n    '    int pivot = arr[high];\\n' +\n    '    int i = low - 1;\\n' +\n    '    for (int j = low; j <= high - 1; ++j)\\n' +\n    '    {\\n' +\n    '        // If current element is smaller than the pivot\\n' +\n    '        if (arr[j] <= pivot)\\n' +\n    '        {\\n' +\n    '            ++i;\\n' +\n    '            swap(&arr[i], &arr[j]);\\n' +\n    '        }\\n' +\n    '    }\\n' +\n    '    // Place pivot in the correct position in the partition\\n' +\n    '    swap(&arr[i + 1], &arr[high]);\\n' +\n    '    return i + 1;\\n' +\n    '}\\n' +\n    '\\n' +\n    'void quickSortHelper(int arr[], int low, int high)\\n' +\n    '{\\n' +\n    '    if (low < high)\\n' +\n    '    {\\n' +\n    '        int pi = partition(arr, low, high);\\n' +\n    '\\n' +\n    '        quickSortHelper(arr, low, pi - 1);\\n' +\n    '        quickSortHelper(arr, pi + 1, high);\\n' +\n    '    }\\n' +\n    '}\\n' +\n    '\\n' +\n    'void quickSort(int arr[], int len)\\n' +\n    '{\\n' +\n    '    quickSortHelper(arr, 0, len - 1);\\n' +\n    '}\\n\\n',\n};\n\nexport default QuickSort;\n","/**\n * Radix sort algorithm details.\n *\n * @memberOf Code templates\n * @const {{Java: string, 'C/C++': string, JavaScript: string, Python: string}}\n */\nconst RadixSort = {\n  Java:\n    'void radixSort(int[] arr) {\\n' +\n    '\\n' +\n    '    // Find the max number and multiply it by 10 to get a number\\n' +\n    '    // with no. of digits of max + 1\\n' +\n    '    int maxNum = arr[0];\\n' +\n    '    for (int num : arr) {\\n' +\n    '        maxNum = Math.max(num, maxNum);\\n' +\n    '    }\\n' +\n    '    maxNum *= 10;\\n' +\n    '    int divisor = 10;\\n' +\n    '    while (divisor < maxNum) {\\n' +\n    '\\n' +\n    '        // Create bucket arrays for each of 0-9\\n' +\n    '        ArrayList<ArrayList<Integer>> buckets = new ArrayList<>(10);\\n' +\n    '        for (int i = 0; i < 10; i++) {\\n' +\n    '            buckets.add(new ArrayList<>());\\n' +\n    '        }\\n' +\n    '\\n' +\n    '        // For each number, get the current significant digit and put it in\\n' +\n    '        // the respective bucket\\n' +\n    '        for (int num : arr) {\\n' +\n    '            int index = (num % divisor) / (divisor / 10);\\n' +\n    '            ArrayList<Integer> currentBucket = buckets.get(index);\\n' +\n    '            currentBucket.add(num);\\n' +\n    '        }\\n' +\n    '\\n' +\n    '        // Reconstruct the array by concatenating all sub arrays\\n' +\n    '        int idx = 0;\\n' +\n    '        for (ArrayList<Integer> bucket : buckets) {\\n' +\n    '            for (int num : bucket) {\\n' +\n    '                arr[idx] = num;\\n' +\n    '                idx++;\\n' +\n    '            }\\n' +\n    '        }\\n\\n' +\n    '        // Move to the next significant digit\\n' +\n    '        divisor *= 10;\\n' +\n    '    }\\n' +\n    '}\\n',\n  JavaScript:\n    'function radixSort(arr) {\\n' +\n    '\\n' +\n    '  // Find the max number and multiply it by 10 to get a number\\n' +\n    '  // with no. of digits of max + 1\\n' +\n    '  const maxNum = Math.max(...arr) * 10;\\n' +\n    '  let divisor = 10;\\n' +\n    '\\n' +\n    '  while (divisor < maxNum) {\\n' +\n    '      \\n' +\n    '    // Create bucket arrays for each of 0-9\\n' +\n    '    let buckets = [...Array(10)].map(() => []);\\n' +\n    '\\n' +\n    '    // For each number, get the current significant digit and put it in\\n' +\n    '    // the respective bucket\\n' +\n    '    for (let num of arr) {\\n' +\n    '      buckets[Math.floor((num % divisor) / (divisor / 10))].push(num);\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Reconstruct the array by concatenating all sub arrays\\n' +\n    '    arr = [].concat.apply([], buckets);\\n' +\n    '\\n' +\n    '    // Move to the next significant digit\\n' +\n    '    divisor *= 10;\\n' +\n    '  }\\n\\n' +\n    '  return arr;\\n' +\n    '}\\n',\n  Python:\n    'def radix_sort(arr):\\n' +\n    '\\n' +\n    '    # Find the max number and multiply it by 10 to get a number\\n' +\n    '    # with no. of digits of max + 1\\n' +\n    '    max_num = max(arr) * 10\\n' +\n    '    divisor = 10\\n' +\n    '\\n' +\n    '    while divisor < max_num:\\n' +\n    '\\n' +\n    '        # Create bucket arrays for each of 0-9\\n' +\n    '        buckets = [None] * 10\\n' +\n    '        for i in range(10):\\n' +\n    '            buckets[i] = []\\n' +\n    '\\n' +\n    '        # For each number, get the current significant digit and put it in\\n' +\n    '        # the respective bucket\\n' +\n    '        for num in arr:\\n' +\n    '            buckets[math.floor((num % divisor) / (divisor / 10))].append(num)\\n' +\n    '\\n' +\n    '        # Reconstruct the array by concatenating all sub arrays\\n' +\n    '        arr = []\\n' +\n    '        for bucket in buckets:\\n' +\n    '            arr.extend(bucket)\\n' +\n    '        divisor *= 10\\n' +\n    '\\n' +\n    '    return arr\\n',\n  'C/C++':\n    'void radixSort(int arr[], int len)\\n' +\n    '{\\n' +\n    '\\n' +\n    '    int maxNum = arr[0];\\n' +\n    '    int i, j, k, divisor = 10;\\n' +\n    '\\n' +\n    '    // Assume that our bucket size is capped at 10 for simplicity\\n' +\n    '    int buckets[10][10];\\n' +\n    '    int bucketCount[10];\\n' +\n    '\\n' +\n    '    // Find the max number and multiply it by 10 to get a number\\n' +\n    '    // with no. of digits of max + 1\\n' +\n    '    for (i = 0; i < len; ++i)\\n' +\n    '    {\\n' +\n    '        if (arr[i] > maxNum)\\n' +\n    '        {\\n' +\n    '            maxNum = arr[i];\\n' +\n    '        }\\n' +\n    '    }\\n' +\n    '    maxNum *= 10;\\n' +\n    '\\n' +\n    '    while (divisor < maxNum)\\n' +\n    '    {\\n' +\n    '        // Initialize bucket arrays for each of 0-9\\n' +\n    '        for (int i = 0; i < 10; ++i)\\n' +\n    '        {\\n' +\n    '            bucketCount[i] = 0;\\n' +\n    '        }\\n' +\n    '\\n' +\n    '        // For each number, get the current significant digit and put it in\\n' +\n    '        // the respective bucket\\n' +\n    '        for (i = 0; i < len; ++i)\\n' +\n    '        {\\n' +\n    '            int num = arr[i];\\n' +\n    '            int index = (num % divisor) / (divisor / 10);\\n' +\n    '            buckets[index][bucketCount[index]] = num;\\n' +\n    '            bucketCount[index]++;\\n' +\n    '        }\\n' +\n    '\\n' +\n    '        // Reconstruct the array by concatenating all sub arrays\\n' +\n    '        i = 0;\\n' +\n    '        for (j = 0; j < 10; ++j)\\n' +\n    '        {\\n' +\n    '            for (k = 0; k < bucketCount[j]; ++k)\\n' +\n    '            {\\n' +\n    '                arr[i] = buckets[j][k];\\n' +\n    '                i++;\\n' +\n    '            }\\n' +\n    '        }\\n' +\n    '\\n' +\n    '        // Move to the next significant digit\\n' +\n    '        divisor *= 10;\\n' +\n    '    }\\n' +\n    '}\\n',\n};\n\nexport default RadixSort;\n","/**\n * Bucket sort algorithm details.\n *\n * @memberOf Code templates\n * @const {{Java: string, 'C/C++': string, JavaScript: string, Python: string}}\n */\nconst BucketSort = {\n  Java:\n    'void bucketSort(double[] arr) {\\n' +\n    '\\n' +\n    '    int totalSlots = 10;\\n' +\n    '    ArrayList<ArrayList<Double>> buckets = new ArrayList<>(totalSlots);\\n' +\n    '\\n' +\n    '    // Create bucket arrays for each of 0-9\\n' +\n    '    for (int i = 0; i < totalSlots; i++) {\\n' +\n    '        buckets.add(new ArrayList<>());\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // For each number, get the digit in the tenth place and put it in\\n' +\n    '    // the respective bucket\\n' +\n    '    for (double num : arr) {\\n' +\n    '        int bucket_idx = (int) (totalSlots * num);\\n' +\n    '        buckets.get(bucket_idx).add(num);\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Sort each bucket in the list of buckets\\n' +\n    '    for (ArrayList<Double> bucket : buckets) {\\n' +\n    '        Collections.sort(bucket);\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Reconstruct the array by concatenating all sub arrays\\n' +\n    '    int index = 0;\\n' +\n    '    for (ArrayList<Double> bucket : buckets) {\\n' +\n    '        for (double item : bucket) {\\n' +\n    '            arr[index] = item;\\n' +\n    '            index++;\\n' +\n    '        }\\n' +\n    '    }\\n' +\n    '}\\n',\n  JavaScript:\n    'function bucketSort(arr) {\\n' +\n    '    \\n' +\n    '  const totalSlots = 10;\\n' +\n    '\\n' +\n    '  // Create bucket arrays for each of 0-9\\n' +\n    '  let buckets = [...Array(10)].map(() => []);\\n' +\n    '\\n' +\n    '  // For each number, get the digit in the tenth place and put it in\\n' +\n    '  // the respective bucket\\n' +\n    '  for (const num of arr) {\\n' +\n    '    const bucket_idx = Math.floor(totalSlots * num);\\n' +\n    '    buckets[bucket_idx].push(num);\\n' +\n    '  }\\n' +\n    '\\n' +\n    '  // Sort each bucket in the list of buckets\\n' +\n    '  for (const bucket of buckets) {\\n' +\n    '    bucket.sort();\\n' +\n    '  }\\n' +\n    '\\n' +\n    '  // Reconstruct the array by concatenating all sub arrays\\n' +\n    '  return [].concat.apply([], buckets);\\n' +\n    '}\\n',\n  Python:\n    'def bucket_sort(arr):\\n' +\n    '\\n' +\n    '    total_slots = 10\\n' +\n    '    buckets = []\\n' +\n    '\\n' +\n    '    # Create bucket arrays for each of 0-9\\n' +\n    '    for i in range(total_slots):\\n' +\n    '        buckets.append([])\\n' +\n    '\\n' +\n    '    # For each number, get the digit in the tenth place and put it in\\n' +\n    '    # the respective bucket\\n' +\n    '    for num in arr:\\n' +\n    '        bucket_idx = int(total_slots * num)\\n' +\n    '        buckets[bucket_idx].append(num)\\n' +\n    '\\n' +\n    '    # Sort each bucket in the list of buckets\\n' +\n    '    for bucket in buckets:\\n' +\n    '        bucket.sort()\\n' +\n    '\\n' +\n    '    # Reconstruct the array by concatenating all sub arrays\\n' +\n    '    index = 0\\n' +\n    '    for bucket in buckets:\\n' +\n    '        for item in bucket:\\n' +\n    '            arr[index] = item\\n' +\n    '            index += 1\\n',\n  'C/C++':\n    'void bucketSort(double arr[], int len)\\n' +\n    '{\\n' +\n    '    int i, j, k;\\n' +\n    '\\n' +\n    '    // Assume that our bucket size is capped at 10 for simplicity\\n' +\n    '    int buckets[10][10];\\n' +\n    '    int bucketCount[10];\\n' +\n    '\\n' +\n    '    // For each number, get the digit in the tenth place and put it in\\n' +\n    '    // the respective bucket\\n' +\n    '    for (i = 0; i < len; ++i)\\n' +\n    '    {\\n' +\n    '        double num = arr[i];\\n' +\n    '        int index = floor(num * 10);\\n' +\n    '        buckets[index][bucketCount[index]] = num;\\n' +\n    '        bucketCount[index]++;\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Sort each bucket in the list of buckets\\n' +\n    '    for (i = 0; i < 10; ++i)\\n' +\n    '    {\\n' +\n    '        sort(buckets[i]);\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Reconstruct the array by concatenating all sub arrays\\n' +\n    '    i = 0;\\n' +\n    '    for (j = 0; j < 10; ++j)\\n' +\n    '    {\\n' +\n    '        for (k = 0; k < bucketCount[j]; ++k)\\n' +\n    '        {\\n' +\n    '            arr[i] = buckets[j][k];\\n' +\n    '            i++;\\n' +\n    '        }\\n' +\n    '    }\\n' +\n    '}\\n',\n};\n\nexport default BucketSort;\n","/**\n * Counting sort algorithm details.\n *\n * @memberOf Code templates\n * @const {{Java: string, 'C/C++': string, JavaScript: string, Python: string}}\n */\nconst CountingSort = {\n  Java:\n    '// Assume array contains only non-zero digits\\n' +\n    'void countingSort(int[] arr) {\\n' +\n    '\\n' +\n    '    int maxElement = arr[0];\\n' +\n    '    // Get max element\\n' +\n    '    for (int i = 1; i < arr.length; i++) {\\n' +\n    '        maxElement = Math.max(maxElement, arr[i]);\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Create count array of length maxElement + 1\\n' +\n    '    int[] countArr = new int[maxElement + 1];\\n' +\n    '\\n' +\n    '    // Fill in count arr\\n' +\n    '    for (int i = 0; i < arr.length; i++) {\\n' +\n    '        countArr[arr[i]]++;\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Insert elements back into original array\\n' +\n    '    int index = 0;\\n' +\n    '    for (int i = 0; i < countArr.length; i++) {\\n' +\n    '        while (countArr[i] != 0) {\\n' +\n    '            arr[index] = i;\\n' +\n    '            index++;\\n' +\n    '            countArr[i]--;\\n' +\n    '        }\\n' +\n    '    }\\n' +\n    '}\\n',\n  JavaScript:\n    '// Assume array contains only non-zero digits\\n' +\n    'function countingSort(arr) {\\n' +\n    '  // Get max element\\n' +\n    '  const maxElement = Math.max(...arr);\\n' +\n    '\\n' +\n    '  // Create count array of length maxElement + 1\\n' +\n    '  const countArr = new Array(maxElement + 1);\\n' +\n    '  countArr.fill(0);\\n' +\n    '\\n' +\n    '  // Fill in count arr\\n' +\n    '  for (let i = 0; i < arr.length; i++) {\\n' +\n    '    countArr[arr[i]]++;\\n' +\n    '  }\\n' +\n    '\\n' +\n    '  // Insert elements back into original array\\n' +\n    '  let index = 0;\\n' +\n    '  for (let i = 0; i < countArr.length; i++) {\\n' +\n    '    while (countArr[i] != 0) {\\n' +\n    '      arr[index] = i;\\n' +\n    '      index++;\\n' +\n    '      countArr[i]--;\\n' +\n    '    }\\n' +\n    '  }\\n' +\n    '}\\n',\n  Python:\n    '# Assume array contains only non-zero digits\\n' +\n    'def counting_sort(arr):\\n' +\n    '    # Get max element\\n' +\n    '    max_element = max(arr)\\n' +\n    '\\n' +\n    '    # Create count array of length max_element + 1\\n' +\n    '    count_arr = [0] * (max_element + 1)\\n' +\n    '\\n' +\n    '    # Fill in count arr\\n' +\n    '    for i in range(len(arr)):\\n' +\n    '        count_arr[arr[i]] += 1\\n' +\n    '\\n' +\n    '    # Insert elements back into original array\\n' +\n    '    index = 0\\n' +\n    '    for i in range(len(count_arr)):\\n' +\n    '        while count_arr[i] is not 0:\\n' +\n    '            arr[index] = i\\n' +\n    '            index += 1\\n' +\n    '            count_arr[i] -= 1\\n',\n  'C/C++':\n    '// Assume array contains only non-zero digits\\n' +\n    'void countingSort(int arr[], int len)\\n' +\n    '{\\n' +\n    '    int i;\\n' +\n    '    int maxElement = arr[0];\\n' +\n    '    // Get max element\\n' +\n    '    for (i = 1; i < len; ++i)\\n' +\n    '    {\\n' +\n    '        if (arr[i] > maxElement)\\n' +\n    '        {\\n' +\n    '            maxElement = arr[i];\\n' +\n    '        }\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Create array with length maxElement + 1\\n' +\n    '    int countArrLength = maxElement + 1;\\n' +\n    '    int *countArr = (int *)malloc(countArrLength * sizeof(int));\\n' +\n    '\\n' +\n    '    for (i = 0; i < countArrLength; ++i)\\n' +\n    '    {\\n' +\n    '        countArr[i] = 0;\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Fill in count arr\\n' +\n    '    for (i = 0; i < len; ++i)\\n' +\n    '    {\\n' +\n    '        countArr[arr[i]]++;\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Insert elements back into original array\\n' +\n    '    int index = 0;\\n' +\n    '    for (i = 0; i < countArrLength; ++i)\\n' +\n    '    {\\n' +\n    '        while (countArr[i] != 0)\\n' +\n    '        {\\n' +\n    '            arr[index] = i;\\n' +\n    '            ++index;\\n' +\n    '            countArr[i]--;\\n' +\n    '        }\\n' +\n    '    }\\n' +\n    '}\\n\\n',\n};\n\nexport default CountingSort;\n","/**\n * Selection sort algorithm details.\n *\n * @see {@link https://www.geeksforgeeks.org/selection-sort/|Geeks for Geeks}\n * @see {@link https://stackabuse.com/selection-sort-in-javascript/|StackAbuse}\n * @see {@link https://stackabuse.com/selection-sort-in-python/|StackAbuse}\n * @memberOf Code templates\n * @const {{Java: string, 'C/C++': string, JavaScript: string, Python: string}}\n */\nconst SelectionSort = {\n  Java:\n    'void sort(int[] arr) {\\n' +\n    '    int n = arr.length;\\n' +\n    '    // One by one move boundary of unsorted subarray \\n' +\n    '    for (int i = 0; i < n - 1; i++) {\\n' +\n    '        // Find the minimum element in unsorted array \\n' +\n    '        int minIdx = i;\\n' +\n    '        for (int j = i + 1; j < n; j++) {\\n' +\n    '            if (arr[j] < arr[min_idx]) {\\n' +\n    '                minIdx = j;\\n' +\n    '            }\\n' +\n    '        }\\n' +\n    '        // Swap the found minimum element with the first element \\n' +\n    '        int temp = arr[minIdx];\\n' +\n    '        arr[minIdx] = arr[i];\\n' +\n    '        arr[i] = temp;\\n' +\n    '    }\\n' +\n    '} \\n',\n  JavaScript:\n    'function selectionSort(inputArr) {\\n' +\n    '  let n = inputArr.length;\\n' +\n    '  for (let i = 0; i < n - 1; i++) {\\n' +\n    '    // Finding the smallest number in the subarray\\n' +\n    '    let min = i;\\n' +\n    '    for (let j = i + 1; j < n; j++) {\\n' +\n    '      if (inputArr[j] < inputArr[min]) {\\n' +\n    '        min = j;\\n' +\n    '      }\\n' +\n    '    }\\n' +\n    '    if (min != i) {\\n' +\n    '      // Swapping the elements\\n' +\n    '      let tmp = inputArr[i];\\n' +\n    '      inputArr[i] = inputArr[min];\\n' +\n    '      inputArr[min] = tmp;\\n' +\n    '    }\\n' +\n    '  }\\n' +\n    '  return inputArr;\\n' +\n    '}\\n',\n  Python:\n    'def selection_sort(L):\\n' +\n    '    # i indicates how many items were sorted\\n' +\n    '    for i in range(len(L) - 1):\\n' +\n    '        # To find the minimum value of the unsorted segment\\n' +\n    '        # We first assume that the first element is the lowest\\n' +\n    '        min_index = i\\n' +\n    '        # We then use j to loop through the remaining elements\\n' +\n    '        for j in range(i + 1, len(L) - 1):\\n' +\n    '            # Update the min_index if the element at j is lower than it\\n' +\n    '            if L[j] < L[min_index]:\\n' +\n    '                min_index = j\\n' +\n    '        # After finding the lowest item of the unsorted regions,\\n' +\n    '        # swap with the first unsorted item\\n' +\n    '        L[i], L[min_index] = L[min_index], L[i]\\n',\n  'C/C++':\n    'void selectionSort(int arr[], int n)\\n' +\n    '{\\n' +\n    '    int i, j, minIdx;\\n' +\n    '    // One by one move boundary of unsorted subarray \\n' +\n    '    for (i = 0; i < n - 1; i++)\\n' +\n    '    {\\n' +\n    '        // Find the minimum element in unsorted array \\n' +\n    '        minIdx = i;\\n' +\n    '        for (j = i + 1; j < n; j++) \\n' +\n    '        {\\n' +\n    '            if (arr[j] < arr[min_idx]) \\n' +\n    '            {\\n' +\n    '                minIdx = j;\\n' +\n    '            }\\n' +\n    '        }\\n' +\n    '        // Swap the found minimum element with the first element \\n' +\n    '        swap(&arr[minIdx], &arr[i]);\\n' +\n    '    }\\n' +\n    '} \\n',\n};\n\nexport default SelectionSort;\n","/**\n * Merge sort algorithm details.\n *\n * @see {@link https://www.geeksforgeeks.org/merge-sort/|Geeks for Geeks}\n * @see {@link https://stackabuse.com/merge-sort-in-javascript/|StackAbuse}\n * @memberOf Code templates\n * @const {{Java: string, 'C/C++': string, JavaScript: string, Python: string}}\n */\nconst MergeSort = {\n  Java:\n    '/* Merges two subarrays of arr[]. First subarray is arr[l..m]\\n' +\n    ' * Second subarray is arr[m+1..r] */\\n' +\n    'void merge(int[] arr, int left, int mid, int right) {\\n' +\n    '    // Find sizes of two subarrays to be merged\\n' +\n    '    int n1 = mid - left + 1;\\n' +\n    '    int n2 = right - mid;\\n' +\n    '\\n' +\n    '    // Create temp arrays\\n' +\n    '    int[] leftArray = new int[n1];\\n' +\n    '    int[] rightArray = new int[n2];\\n' +\n    '\\n' +\n    '    // Copy data to temp arrays\\n' +\n    '    for (int i = 0; i < n1; i++) {\\n' +\n    '        leftArray[i] = arr[left + i];\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    for (int j = 0; j < n2; j++) {\\n' +\n    '        rightArray[j] = arr[mid + 1 + j];\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Initial indexes of first and second subarrays\\n' +\n    '    int i = 0, j = 0;\\n' +\n    '\\n' +\n    '    // Initial index of merged subarray array\\n' +\n    '    int k = left;\\n' +\n    '    // Merge the arrays\\n' +\n    '    while (i < n1 && j < n2) {\\n' +\n    '        if (leftArray[i] <= rightArray[j]) {\\n' +\n    '            arr[k++] = leftArray[i++];\\n' +\n    '        } else {\\n' +\n    '            arr[k++] = rightArray[j++];\\n' +\n    '        }\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Copy remaining elements of leftArray if any\\n' +\n    '    while (i < n1) {\\n' +\n    '        arr[k++] = leftArray[i++];\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Copy remaining elements of rightArray if any\\n' +\n    '    while (j < n2) {\\n' +\n    '        arr[k++] = rightArray[j++];\\n' +\n    '    }\\n' +\n    '}\\n' +\n    '\\n' +\n    '// Main function that sorts arr[l..r] using merge()\\n' +\n    'void mergeSortHelper(int[] arr, int left, int right) {\\n' +\n    '    if (left < right) {\\n' +\n    '        // Find the middle point\\n' +\n    '        int mid = (left + right) / 2;\\n' +\n    '\\n' +\n    '        // Sort first and second halves\\n' +\n    '        mergeSortHelper(arr, left, mid);\\n' +\n    '        mergeSortHelper(arr, mid + 1, right);\\n' +\n    '\\n' +\n    '        // Merge the sorted halves\\n' +\n    '        merge(arr, left, mid, right);\\n' +\n    '    }\\n' +\n    '}\\n' +\n    '\\n' +\n    'void mergeSort(int[] arr) {\\n' +\n    '    mergeSortHelper(arr, 0, arr.length - 1);\\n' +\n    '}\\n',\n  JavaScript:\n    'function merge(left, right) {\\n' +\n    '  let arr = []\\n' +\n    '  // Break out of loop if any one of the array gets empty\\n' +\n    '  while (left.length && right.length) {\\n' +\n    '    // Pick the smaller element of left and right sub arrays \\n' +\n    '    if (left[0] < right[0]) {\\n' +\n    '      arr.push(left.shift())\\n' +\n    '    } else {\\n' +\n    '      arr.push(right.shift())\\n' +\n    '    }\\n' +\n    '  }\\n' +\n    '\\n' +\n    '  /* Concatenating the leftover elements\\n' +\n    \"   * (in case we didn't go through the entire left or right array) */\\n\" +\n    '  return [ ...arr, ...left, ...right ]\\n' +\n    '}\\n' +\n    '\\n' +\n    'function mergeSort(array) {\\n' +\n    '  const half = array.length / 2;\\n' +\n    '\\n' +\n    '  // Base case or terminating case\\n' +\n    '  if (array.length < 2) {\\n' +\n    '    return array;\\n' +\n    '  }\\n' +\n    '\\n' +\n    '  const left = array.splice(0, half);\\n' +\n    '  return merge(mergeSort(left), mergeSort(array));\\n' +\n    '}\\n',\n  Python:\n    'def mergeSort(arr):\\n' +\n    '    if len(arr) > 1:\\n' +\n    '        # Finding the mid of the array\\n' +\n    '        mid = len(arr)//2\\n' +\n    '        # Dividing the array elements\\n' +\n    '        left_array = arr[:mid]\\n' +\n    '        # into 2 halves\\n' +\n    '        right_array = arr[mid:]\\n' +\n    '        # Sorting the first half\\n' +\n    '        mergeSort(left_array)\\n' +\n    '        # Sorting the second half\\n' +\n    '        mergeSort(right_array)\\n' +\n    '\\n' +\n    '        i = j = k = 0\\n' +\n    '\\n' +\n    '        # Copy data to temp arrays left_array and right_array\\n' +\n    '        while i < len(left_array) and j < len(right_array):\\n' +\n    '            if left_array[i] < right_array[j]:\\n' +\n    '                arr[k] = left_array[i]\\n' +\n    '                i += 1\\n' +\n    '            else:\\n' +\n    '                arr[k] = right_array[j]\\n' +\n    '                j += 1\\n' +\n    '            k += 1\\n' +\n    '\\n' +\n    '        # Checking if any element was left\\n' +\n    '        while i < len(left_array):\\n' +\n    '            arr[k] = left_array[i]\\n' +\n    '            i += 1\\n' +\n    '            k += 1\\n' +\n    '\\n' +\n    '        while j < len(right_array):\\n' +\n    '            arr[k] = right_array[j]\\n' +\n    '            j += 1\\n' +\n    '            k += 1\\n',\n  'C/C++':\n    '// Merges two subarrays of arr[]. First subarray is arr[l..m] \\n' +\n    '// Second subarray is arr[m+1..r] \\n' +\n    'void merge(int arr[], int left, int mid, int right)\\n' +\n    '{\\n' +\n    '    int i, j, k;\\n' +\n    '    int n1 = mid - left + 1;\\n' +\n    '    int n2 = right - mid;\\n' +\n    '\\n' +\n    '    // create temp arrays\\n' +\n    '    int leftArray[n1], rightArray[n2];\\n' +\n    '\\n' +\n    '    // Copy data to temp arrays leftArray and rightArray\\n' +\n    '    for (i = 0; i < n1; ++i) \\n' +\n    '    {\\n' +\n    '        leftArray[i] = arr[l + i];\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    for (j = 0; j < n2; ++j) \\n' +\n    '    {\\n' +\n    '        rightArray[j] = arr[m + 1 + j];\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Merge the temp arrays back into arr[l..r]\\n' +\n    '    i = 0; // Initial index of first subarray\\n' +\n    '    j = 0; // Initial index of second subarray\\n' +\n    '    k = left; // Initial index of merged subarray\\n' +\n    '    while (i < n1 && j < n2) \\n' +\n    '    {\\n' +\n    '        if (leftArray[i] <= rightArray[j]) \\n' +\n    '        {\\n' +\n    '            arr[k++] = leftArray[i++];\\n' +\n    '        }\\n' +\n    '        else \\n' +\n    '        {\\n' +\n    '            arr[k++] = rightArray[j++];\\n' +\n    '        }\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Copy the remaining elements of leftArray, if there are any\\n' +\n    '    while (i < n1) \\n' +\n    '    {\\n' +\n    '        arr[k++] = leftArray[i++];\\n' +\n    '    }\\n' +\n    '\\n' +\n    '    // Copy the remaining elements of rightArray, if there are any \\n' +\n    '    while (j < n2) \\n' +\n    '    {\\n' +\n    '        arr[k++] = rightArray[j++];\\n' +\n    '    }\\n' +\n    '}\\n' +\n    '\\n' +\n    '// left is for left index and right is right index \\n' +\n    '// of the sub-array of arr to be sorted \\n' +\n    'void mergeSort(int arr[], int left, int right)\\n' +\n    '{\\n' +\n    '    if (left < right) \\n' +\n    '    {\\n' +\n    '        // Same as (left + right) / 2, \\n' +\n    '        // but avoids overflow for large left and right \\n' +\n    '        int mid = left + (right - left) / 2;\\n' +\n    '\\n' +\n    '        // Sort first and second halves\\n' +\n    '        mergeSort(arr, left, mid);\\n' +\n    '        mergeSort(arr, mid + 1, right);\\n' +\n    '\\n' +\n    '        merge(arr, left, mid, right);\\n' +\n    '    }\\n' +\n    '}\\n',\n};\n\nexport default MergeSort;\n","/**\n * Shell sort algorithm details.\n *\n * @see {@link https://levelup.gitconnected.com/shell-sort-in-javascript-c8a487041cdb|GitConnected}\n * @see {@link https://www.geeksforgeeks.org/shellsort/|Geeks for Geeks}\n * @memberOf Code templates\n * @const {{Java: string, 'C/C++': string, JavaScript: string, Python: string}}\n */\nconst ShellSort = {\n  Java:\n    'void shellSort(int[] arr) { \\n' +\n    '    int n = arr.length; \\n' +\n    '\\n' +\n    '    // Start with a big gap, then reduce the gap \\n' +\n    '    for (int gap = n / 2; gap > 0; gap /= 2) { \\n' +\n    '\\n' +\n    '    // Do a gapped insertion sort for this gap size \\n' +\n    '        for (int i = gap; i < n; i += 1) { \\n' +\n    '        int temp = arr[i]; \\n' +\n    '\\n' +\n    '        // Shift earlier gap-sorted elements up until \\n' +\n    '        // the correct location for a[i] is found \\n' +\n    '        int j; \\n' +\n    '        for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) { \\n' +\n    '            arr[j] = arr[j - gap]; \\n' +\n    '\\n' +\n    '            // Put temp (the original a[i]) in its correct location \\n' +\n    '            arr[j] = temp; \\n' +\n    '        } \\n' +\n    '    } \\n' +\n    '} \\n',\n  JavaScript:\n    'function shellSort(arr) {\\n' +\n    '  let n = arr.length;\\n' +\n    '  \\n' +\n    \"  // Start with a really large gap, and then reduce the gap until there isn't any. \\n\" +\n    '  // With this, the gap starts as half of the array length, and then half of that \\n' +\n    '  // every time \\n' +\n    '  for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) { \\n' +\n    '  \\n' +\n    '    // Do a insertion sort for each of the section the gap ends up dividing \\n' +\n    '    for (let i = gap; i < n; i += 1) { \\n' +\n    '  \\n' +\n    '      // We store the current variable \\n' +\n    '      let temp = arr[i]; \\n' +\n    '  \\n' +\n    '      // This is the insertion sort to sort the section into order \\n' +\n    '      let j; \\n' +\n    '      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) { \\n' +\n    '        arr[j] = arr[j - gap]; \\n' +\n    '      }\\n' +\n    '      arr[j] = temp;\\n' +\n    '    } \\n' +\n    '  } \\n' +\n    '  return arr;\\n' +\n    '} \\n',\n  Python:\n    'def shellSort(arr): \\n' +\n    '\\n' +\n    '    # Start with a big gap, then reduce the gap \\n' +\n    '    n = len(arr) \\n' +\n    '    gap = n // 2\\n' +\n    '\\n' +\n    '    # Do a gapped insertion sort for this gap size' +\n    '    while gap > 0: \\n' +\n    '        for i in range(gap, n): \\n' +\n    '            temp = arr[i] \\n' +\n    '  \\n' +\n    '            # Shift earlier gap-sorted elements up until the correct \\n' +\n    '            # location for a[i] is found \\n' +\n    '            j = i \\n' +\n    '            while  j >= gap and arr[j - gap] > temp: \\n' +\n    '                arr[j] = arr[j - gap] \\n' +\n    '                j -= gap \\n' +\n    '  \\n' +\n    '            # Put temp (the original a[i]) in its correct location \\n' +\n    '            arr[j] = temp \\n' +\n    '        gap //= 2 \\n',\n  'C/C++':\n    'int shellSort(int arr[], int n) \\n' +\n    '{ \\n' +\n    '    // Start with a big gap, then reduce the gap \\n' +\n    '    for (int gap = n / 2; gap > 0; gap /= 2) \\n' +\n    '    { \\n' +\n    '        // Do a gapped insertion sort for this gap size \\n' +\n    '        for (int i = gap; i < n; i += 1) \\n' +\n    '        { \\n' +\n    '            int temp = arr[i]; \\n' +\n    '  \\n' +\n    '            // Shift earlier gap-sorted elements up until the correct  \\n' +\n    '            // location for a[i] is found \\n' +\n    '            int j; \\n' +\n    '            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\\n' +\n    '                arr[j] = arr[j - gap]; \\n' +\n    '            } \\n' +\n    '  \\n' +\n    '            // Put temp (the original a[i]) in its correct location \\n' +\n    '            arr[j] = temp; \\n' +\n    '        } \\n' +\n    '    } \\n' +\n    '    return 0; \\n' +\n    '} \\n',\n};\n\nexport default ShellSort;\n","/**\n * Heap sort algorithm details.\n *\n * @see {@link https://www.geeksforgeeks.org/heap-sort/|Geeks for Geeks}\n * @see {@link https://www.w3resource.com/javascript-exercises/searching-and-sorting-algorithm/searching-and-sorting-algorithm-exercise-3.php|w3resource}\n * @memberOf Code templates\n * @const {{Java: string, 'C/C++': string, JavaScript: string, Python: string}}\n */\nconst HeapSort = {\n  Java:\n    '// To heapify a sub-tree rooted with node i which is \\n' +\n    '// an index in arr[]. n is size of heap \\n' +\n    'void heapify(int[] arr, int n, int i) { \\n' +\n    '    int largest = i; // Initialize largest as root \\n' +\n    '    int l = 2 * i + 1; // left = 2 * i + 1 \\n' +\n    '    int r = 2 * i + 2; // right = 2 * i + 2 \\n' +\n    ' \\n' +\n    '    // If left child is larger than root \\n' +\n    '    if (l < n && arr[l] > arr[largest]) \\n' +\n    '        largest = l; \\n' +\n    ' \\n' +\n    '    // If right child is larger than largest so far \\n' +\n    '    if (r < n && arr[r] > arr[largest]) \\n' +\n    '        largest = r; \\n' +\n    ' \\n' +\n    '    // If largest is not root \\n' +\n    '    if (largest != i) { \\n' +\n    '        int swap = arr[i]; \\n' +\n    '        arr[i] = arr[largest]; \\n' +\n    '        arr[largest] = swap; \\n' +\n    ' \\n' +\n    '        // Recursively heapify the affected sub-tree \\n' +\n    '        heapify(arr, n, largest); \\n' +\n    '    }\\n' +\n    '} \\n' +\n    ' \\n' +\n    'void sort(int[] arr) {\\n' +\n    '    int n = arr.length;\\n' +\n    ' \\n' +\n    '    // Build heap (rearrange array) \\n' +\n    '    for (int i = n / 2 - 1; i >= 0; i--) { \\n' +\n    '        heapify(arr, n, i); \\n' +\n    '    } \\n' +\n    ' \\n' +\n    '    // One by one extract an element from heap\\n' +\n    '    for (int i = n - 1; i > 0; i--) { \\n' +\n    ' \\n' +\n    '        // Move current root to end \\n' +\n    '        int temp = arr[0]; \\n' +\n    '        arr[0] = arr[i]; \\n' +\n    '        arr[i] = temp; \\n' +\n    ' \\n' +\n    '        // Call max heapify on the reduced heap \\n' +\n    '        heapify(arr, i, 0); \\n' +\n    '    } \\n' +\n    '} \\n',\n  JavaScript:\n    'let array_length; \\n' +\n    '\\n' +\n    '// To heapify a sub-tree rooted with node i which is \\n' +\n    '// an index in arr[] \\n' +\n    'function heap_root(input, i) { \\n' +\n    '  let left = 2 * i + 1; \\n' +\n    '  let right = 2 * i + 2; \\n' +\n    '  let max = i; \\n' +\n    '\\n' +\n    '  // If left child is larger than root \\n' +\n    '  if (left < array_length && input[left] > input[max]) { \\n' +\n    '    max = left;\\n' +\n    '  }\\n' +\n    '\\n' +\n    '  // If right child is larger than largest so far \\n' +\n    '  if (right < array_length && input[right] > input[max])     { \\n' +\n    '    max = right; \\n' +\n    '  } \\n' +\n    '\\n' +\n    '  // If largest is not root \\n' +\n    '  if (max != i) { \\n' +\n    '    swap(input, i, max); \\n' +\n    '\\n' +\n    '    // Recursively heapify the affected sub-tree \\n' +\n    '    heap_root(input, max); \\n' +\n    '  } \\n' +\n    '} \\n' +\n    '\\n' +\n    'function swap(input, index_A, index_B) { \\n' +\n    '  let temp = input[index_A]; \\n' +\n    '\\n' +\n    '  input[index_A] = input[index_B]; \\n' +\n    '  input[index_B] = temp; \\n' +\n    '} \\n' +\n    '\\n' +\n    'function heapSort(arr) { \\n' +\n    '    \\n' +\n    '  array_length = arr.length; \\n' +\n    '\\n' +\n    '  // Build heap (rearrange array) \\n' +\n    '  for (let i = Math.floor(array_length / 2); i >= 0; i -= 1) {\\n' +\n    '    heap_root(arr, i); \\n' +\n    '  } \\n' +\n    '\\n' +\n    '  // One by one extract an element from heap\\n' +\n    '  for (i = arr.length - 1; i > 0; i--) { \\n' +\n    '    // Move current root to end \\n' +\n    '    swap(arr, 0, i); \\n' +\n    '    array_length--; \\n' +\n    '\\n' +\n    '    // Call max heapify on the reduced heap \\n' +\n    '    heap_root(arr, 0); \\n' +\n    '  }\\n' +\n    '} \\n',\n  Python:\n    '# To heapify sub-tree rooted at index i. n is size of heap \\n' +\n    'def heapify(arr, n, i): \\n' +\n    '    largest = i  # Initialize largest as root \\n' +\n    '    l = 2 * i + 1     # left = 2 * i + 1 \\n' +\n    '    r = 2 * i + 2     # right = 2 * i + 2 \\n' +\n    ' \\n' +\n    '    # See if left child of root exists and is \\n' +\n    '    # greater than root \\n' +\n    '    if l < n and arr[largest] < arr[l]: \\n' +\n    '        largest = l \\n' +\n    ' \\n' +\n    '    # See if right child of root exists and is \\n' +\n    '    # greater than root \\n' +\n    '    if r < n and arr[largest] < arr[r]: \\n' +\n    '        largest = r \\n' +\n    ' \\n' +\n    '    # Change root, if needed \\n' +\n    '    if largest != i:\\n' +\n    '        arr[i], arr[largest] = arr[largest], arr[i]  # swap\\n' +\n    ' \\n' +\n    '        # Heapify the root \\n' +\n    '        heapify(arr, n, largest)\\n' +\n    ' \\n' +\n    'def heapSort(arr): \\n' +\n    '    n = len(arr) \\n' +\n    ' \\n' +\n    '    # Build a maxheap \\n' +\n    '    for i in range(n//2 - 1, -1, -1): \\n' +\n    '        heapify(arr, n, i) \\n' +\n    ' \\n' +\n    '    # One by one extract elements \\n' +\n    '    for i in range(n-1, 0, -1): \\n' +\n    '        // Move current root to end \\n' +\n    '        arr[i], arr[0] = arr[0], arr[i] \\n' +\n    '        heapify(arr, i, 0) \\n',\n  'C/C++':\n    '#include <iostream> \\n' +\n    ' \\n' +\n    '// To heapify a sub-tree rooted with node i which is\\n' +\n    '// an index in arr[]. n is size of heap\\n' +\n    'void heapify(int arr[], int n, int i) \\n' +\n    '{ \\n' +\n    '    int largest = i; // Initialize largest as root\\n' +\n    '    int l = 2 * i + 1; // left = 2 * i + 1 \\n' +\n    '    int r = 2 * i + 2; // right = 2 * i + 2 \\n' +\n    ' \\n' +\n    '    // If left child is larger than root \\n' +\n    '    if (l < n && arr[l] > arr[largest]) \\n' +\n    '        largest = l; \\n' +\n    ' \\n' +\n    '    // If right child is larger than largest so far \\n' +\n    '    if (r < n && arr[r] > arr[largest])\\n' +\n    '        largest = r;\\n' +\n    ' \\n' +\n    '    // If largest is not root\\n' +\n    '    if (largest != i) { \\n' +\n    '        swap(arr[i], arr[largest]); \\n' +\n    ' \\n' +\n    '        // Recursively heapify the affected sub-tree \\n' +\n    '        heapify(arr, n, largest); \\n' +\n    '    } \\n' +\n    '} \\n' +\n    ' \\n' +\n    'void heapSort(int arr[], int n) \\n' +\n    '{ \\n' +\n    '    // Build heap (rearrange array) \\n' +\n    '    for (int i = n / 2 - 1; i >= 0; i--) \\n' +\n    '        heapify(arr, n, i);\\n' +\n    ' \\n' +\n    '    // One by one extract an element from heap \\n' +\n    '    for (int i = n - 1; i > 0; i--) { \\n' +\n    '        // Move current root to end \\n' +\n    '        swap(arr[0], arr[i]);\\n' +\n    ' \\n' +\n    '        // Call max heapify on the reduced heap \\n' +\n    '        heapify(arr, i, 0); \\n' +\n    '    }\\n' +\n    '} \\n',\n};\n\nexport default HeapSort;\n","import React from 'react';\nimport './styles.css';\n\n/**\n * Selector component which allows the users to select the code corresponding to the programming\n * language.\n *\n * @component\n * @category CodeTemplate\n * @returns {JSX.Element} Selector component.\n */\nconst Selector = ({ selected, setSelected }) => {\n  /**\n   * Select button for users to choose the programming language.\n   *\n   * @param language Programming language.\n   * @returns {JSX.Element} Select button.\n   */\n  const Select = ({ language }) => (\n    <p\n      className=\"select\"\n      style={{\n        background: selected === language ? `linear-gradient(0deg, #7c89f8, #5466ff)` : `#A5BBC9`,\n      }}\n      onClick={() => setSelected(language)}\n    >\n      {language}\n    </p>\n  );\n\n  return (\n    <div className=\"selector\">\n      <Select language={'Java'} />\n      <Select language={'JavaScript'} />\n      <Select language={'Python'} />\n      <Select language={'C/C++'} />\n    </div>\n  );\n};\n\nexport default Selector;\n","import React, { useEffect, useState } from 'react';\nimport templates from '../templates/Templates';\nimport Selector from './Selector';\nimport './styles.css';\nimport AceEditor from 'react-ace';\nimport 'ace-builds/webpack-resolver';\nimport 'ace-builds/src-noconflict/mode-java';\nimport 'ace-builds/src-noconflict/mode-python';\nimport 'ace-builds/src-noconflict/mode-c_cpp';\nimport 'ace-builds/src-noconflict/mode-javascript';\nimport 'ace-builds/src-noconflict/theme-textmate';\n\n/**\n * Code template which encapsulates the details for the programming language selectors and code\n * editor.\n *\n * @component\n * @category CodeTemplate\n * @param {string} algo Current algorithm selected.\n * @returns {JSX.Element} Code template component.\n */\nconst CodeTemplate = ({ algo }) => {\n  // Code templates used of this algorithm\n  const [template, setTemplate] = useState(() => templates[algo]);\n\n  // Current programming language selected\n  const [selected, setSelected] = useState('Java');\n\n  useEffect(() => {\n    setTemplate(templates[algo]);\n  }, [algo]);\n\n  /**\n   * Gets the current mode corresponding to the programming language selected.\n   *\n   * @returns {string} Current mode.\n   */\n  const getMode = () => (selected === 'C/C++' ? 'c_cpp' : selected.toLowerCase());\n\n  return (\n    <div className=\"code-template\">\n      <Selector selected={selected} setSelected={setSelected} />\n      <AceEditor\n        className=\"editor\"\n        mode={getMode()}\n        theme=\"textmate\"\n        fontSize={14}\n        name=\"UNIQUE_ID_OF_DIV\"\n        editorProps={{ $blockScrolling: true }}\n        value={template[selected]}\n        readOnly={true}\n      />\n    </div>\n  );\n};\n\nexport default CodeTemplate;\n","import CodeExplanation from './codeexplaination/CodeExplanation';\nimport CodeTemplate from './codetemplate/CodeTemplate';\nimport React from 'react';\nimport './styles.css';\n\n/**\n * Code information component which provides information on the current sorting algorithm.\n *\n * @component\n * @category App Body\n * @param {string} visualizerAlgorithm Current sorting algorithm selected.\n * @returns {JSX.Element} Code information component which provides information on the current sorting algorithm.\n */\nconst CodeInformation = ({ visualizerAlgorithm }) => (\n  <div className=\"code\">\n    <CodeExplanation algo={visualizerAlgorithm} />\n    <CodeTemplate algo={visualizerAlgorithm} />\n  </div>\n);\n\nexport default CodeInformation;\n","import React, { useEffect, useState } from 'react';\nimport Legend from './component/legend/Legend';\nimport SectionHeader from '../../component/header/SectionHeader';\nimport AlgorithmSelector from './component/selectors/algorithmselector/AlgorithmSelector';\nimport SpeedSelector from './component/selectors/sliderselector/SliderSelector';\nimport DataSizeSelector from './component/selectors/sliderselector/SliderSelector';\nimport './styles.css';\nimport {\n  isBucketSort,\n  isCountingSort,\n  isMergeSort,\n  isQuickSort,\n  isRadixSort,\n} from './util/GeneralUtil';\nimport { roundToTwoDp } from './util/MathUtil';\nimport { executeGenericSort } from './util/SwappingAlgoUtil';\nimport { executeMergeSortBackward, executeMergeSortForward } from './util/MergeSortUtil';\nimport { executeQuickSort } from './util/QuickSortUtil';\nimport { buckets, executeCountSort } from './util/CountingSortUtil';\nimport { executeRadixSort, stack } from './util/RadixSortUtil';\nimport {\n  DataSizeSelectorProps,\n  SpeedSelectorProps,\n} from './component/selectors/sliderselector/SelectorProps';\nimport AnimationProgressBar from './component/animationprogressbar/AnimationProgressBar';\nimport AnimationScreen from './component/animationscreen/AnimationScreen';\nimport StepByStep from './component/stepbystep/StepByStep';\nimport bubbleSort from '../algorithm/sortingalgorithms/bubbleSort';\nimport { executeBucketSort } from './util/BucketSortUtil';\nimport ButtonBox from './component/button/ButtonBox';\nimport CodeInformation from '../codeinformation/CodeInformation';\nimport { arrayCopy, generateArray, getAnimationArr, resetArray } from './util/ArrayUtil';\nimport { KeyboardReturnRounded } from '@material-ui/icons';\n\nconst VisualizerStateContext = React.createContext({ isPlay: false, isReplay: false });\n\n/**\n * Encapsulates the fields and methods of the Visualizer Component.\n *\n * @category App Body\n * @component\n * @returns {JSX.Element} Visualizer Component.\n */\nconst Visualizer = () => {\n  // isPlay and isReplay simulate the 3 states\n  const [isPlay, setIsPlay] = useState(false);\n  const [isReplay, setIsReplay] = useState(false);\n\n  // this is to ensure we can click back arrow without trigger any new re-rendering of data\n  const [isReset, setIsReset] = useState(false);\n\n  const [isInMidstOfSort, setIsInMidstOfSort] = useState(false);\n  const [speed, setSpeed] = useState(5);\n  const [dataSize, setDataSize] = useState(15);\n  const [visualizerAlgorithm, setVisualizerAlgorithm] = useState('Bubble Sort');\n\n  // Original state of the array\n  const [arrayData, setArrayData] = useState(() => generateArray(dataSize, visualizerAlgorithm));\n\n  // Reference array used to display the array being animated\n  const [referenceArray, setReferenceArray] = useState(() => arrayCopy(arrayData));\n\n  // Animation array which contains the steps of the entire animation\n  const [animationArr, setAnimationArr] = useState(() => bubbleSort(arrayCopy(arrayData)));\n\n  // Animation percentage used to describe the percentage of animation completed for the sorting\n  // algorithm\n  const [animationPercentage, setAnimationPercentage] = useState(0);\n\n  // Index of the current animation\n  const [idx, setIdx] = useState(0);\n\n  // Count array used for counting sort\n  const [countArr, setCountArr] = useState(() => arrayCopy(buckets));\n\n  // Stack array used for radix and bucket sort\n  const [stackArr, setStackArr] = useState(() => arrayCopy(stack));\n\n  // This is introduced to simplify the back animation for MergeSort\n  const [historyArr, setHistoryArr] = useState([]);\n\n  useEffect(() => {\n    if (isPlay === false) {\n      setAnimationArr(getAnimationArr(visualizerAlgorithm, arrayCopy(arrayData)));\n    }\n  }, [isPlay, speed, dataSize, visualizerAlgorithm, arrayData]);\n\n  /**\n   * Changes the number of \"block\" or \"ovals\" for the sorting animation.\n   *\n   * @param {number} val The number of \"block\" or \"ovals\" for sorting animation.\n   */\n  const changeDataSize = (val) => {\n    if (val !== dataSize) {\n      setDataSize(val);\n      setArrayData(generateArray(val, visualizerAlgorithm));\n      setCountArr(arrayCopy(buckets));\n      setStackArr(arrayCopy(stack));\n      setIsReplay(false);\n      setAnimationPercentage(0);\n      setIsReset(true);\n    }\n  };\n\n  /**\n   * Executes one step of the sorting animation in the forward direction,\n   * depending on the selected algorithm.\n   */\n  const executeForwardAnimation = () => {\n    let currentAnimation = animationArr[idx];\n    const animationPx = roundToTwoDp(((idx + 1) / animationArr.length) * 100);\n    let nextReferenceArray;\n    if (isCountingSort(visualizerAlgorithm)) {\n      nextReferenceArray = executeCountSort(\n        currentAnimation,\n        referenceArray,\n        animationPx,\n        countArr,\n        true\n      );\n    } else if (isRadixSort(visualizerAlgorithm)) {\n      nextReferenceArray = executeRadixSort(currentAnimation, referenceArray, stackArr, true);\n    } else if (isBucketSort(visualizerAlgorithm)) {\n      nextReferenceArray = executeBucketSort(currentAnimation, referenceArray, stackArr, true);\n    } else if (isMergeSort(visualizerAlgorithm)) {\n      nextReferenceArray = executeMergeSortForward(\n        currentAnimation,\n        referenceArray,\n        historyArr,\n        setReferenceArray\n      );\n    } else if (isQuickSort(visualizerAlgorithm)) {\n      nextReferenceArray = executeQuickSort(\n        currentAnimation,\n        referenceArray,\n        visualizerAlgorithm,\n        setReferenceArray\n      );\n    } else {\n      // Generic Sort refers to Insertion, Bubble, Selection, Shell Sort\n      nextReferenceArray = executeGenericSort(\n        currentAnimation,\n        referenceArray,\n        visualizerAlgorithm,\n        setReferenceArray\n      );\n    }\n\n    if (idx === animationArr.length) {\n      setIsPlay(false);\n      //resetDataWhenAnimationFinish(nextReferenceArray);\n    }\n\n    setIdx(idx + 1);\n    setAnimationPercentage(animationPx);\n  };\n\n  /**\n   * Executes one step of the sorting animation in the reverse direction,\n   * depending on the sorting algorithm.\n   */\n  const executeBackwardAnimation = () => {\n    // this occurs if the users click too fast\n    if (idx - 1 < 0) {\n      setIdx(0);\n      return;\n    }\n    let currentAnimation = animationArr[idx - 1];\n    const animationPx = roundToTwoDp(((idx - 1) / animationArr.length) * 100);\n\n    if (isCountingSort(visualizerAlgorithm)) {\n      executeCountSort(currentAnimation, referenceArray, animationPx, countArr, false);\n    } else if (isRadixSort(visualizerAlgorithm)) {\n      executeRadixSort(currentAnimation, referenceArray, stackArr, false);\n    } else if (isBucketSort(visualizerAlgorithm)) {\n      executeBucketSort(currentAnimation, referenceArray, stackArr, false);\n    } else if (isMergeSort(visualizerAlgorithm)) {\n      executeMergeSortBackward(historyArr, setReferenceArray);\n    } else if (isQuickSort(visualizerAlgorithm)) {\n      executeQuickSort(currentAnimation, referenceArray, visualizerAlgorithm, setReferenceArray);\n    } else {\n      executeGenericSort(currentAnimation, referenceArray, visualizerAlgorithm, setReferenceArray);\n    }\n\n    if (idx === animationArr.length) {\n      setIsReplay(false);\n    }\n    setIdx(idx - 1);\n    setAnimationPercentage(animationPx);\n  };\n\n  /**\n   * Resets the states of the \"blocks\" or \"oval\" when the sorting animation is done.\n   *\n   * @param {Object[]} finalReferenceArray The end state of the array holding the states of each block.\n   */\n  const resetDataWhenAnimationFinish = (finalReferenceArray) => {\n    setIsPlay(false);\n    setIsReplay(true);\n    setReferenceArray(resetArray(visualizerAlgorithm, finalReferenceArray));\n  };\n\n  /**\n   * ContextProviderValue object contains different values and methods to be passed around the other components\n   * via React's context.\n   *\n   * @const {Object}\n   */\n  const value = {\n    isPlay,\n    isReplay,\n    speed,\n    arrayData,\n    referenceArray,\n    animationArr,\n    countArr,\n    stackArr,\n    isInMidstOfSort,\n    dataSize,\n    setDataSize,\n    visualizerAlgorithm,\n    animationPercentage,\n    idx,\n    isReset,\n    setIsReset,\n    setIsReplay,\n    setIsPlay,\n    setIsInMidstOfSort,\n    setVisualizerAlgorithm,\n    setArrayData,\n    setAnimationPercentage,\n    setAnimationArr,\n    setIdx,\n    setReferenceArray,\n    setCountArr,\n    setStackArr,\n    setHistoryArr,\n    executeForwardAnimation,\n    executeBackwardAnimation,\n    resetDataWhenAnimationFinish,\n  };\n\n  return (\n    <div id=\"visualizer\">\n      <VisualizerStateContext.Provider value={{ ...value }}>\n        <div className=\"visualizer\">\n          <div className=\"visualizer-header-box\">\n            <SectionHeader sectionHeader=\"Visualizer\" translateX=\"translate(25px)\" />\n            <AlgorithmSelector />\n          </div>\n          <div className=\"visualizer-box\">\n            <AnimationScreen />\n          </div>\n          <StepByStep />\n          <AnimationProgressBar />\n          <div className=\"controller-box\">\n            <div className=\"speed-selector-box\">\n              <SpeedSelector setData={(val) => setSpeed(val)} {...SpeedSelectorProps} />\n              <DataSizeSelector setData={(val) => changeDataSize(val)} {...DataSizeSelectorProps} />\n            </div>\n            <ButtonBox />\n            <Legend />\n          </div>\n        </div>\n      </VisualizerStateContext.Provider>\n      <CodeInformation visualizerAlgorithm={visualizerAlgorithm} />\n    </div>\n  );\n};\n\nexport { VisualizerStateContext };\nexport default Visualizer;\n","import React from 'react';\nimport './App.css';\n\nimport HowItWorks from '../howitworks/HowItWorks';\n//import ContactUs from '../contactus/ContactUs';\n//import Home from '../home/Home';\n//import Team from '../team/Team';\nimport Visualizer from '../visualizer/sortingvisualizer/Visualizer';\n//import NavigationMenu from '../component/navigationMenu/NavigationMenu';\n\n/**\n * Main controller of the App. Contains a navigation menu and its corresponding sections.\n *\n * @component\n * @category Main App\n */\nfunction App() {\n  return (\n    <div className=\"app\">\n      <div className=\"app-container\">\n        <div className='titlemain'>Sorting Algorithm Applet</div>\n        <div className='descriptionmain'>Visualize the step by step process of popular sorting algorithms!</div>\n        <div className='footermain'>&#169; {new Date().getFullYear()} by <a className='footerlink' href=\"https://www.hjavidnia.com/\" target=\"_blank\">Hossein Javidnia</a></div>\n        <HowItWorks />\n        <Visualizer />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './app/App';\nimport reportWebVitals from './reportWebVitals';\n\n/**\n * Listener to show current navigation window/menu.\n */\n/*window.addEventListener('scroll', (event) => {\n  let navigationLinks = document.querySelectorAll('nav ul li a');\n  let fromTop = window.scrollY + 60 + window.innerHeight * 0.05;\n  let navigationMenu = document.querySelector('nav');\n  let menuHeaders = document.querySelectorAll('nav div a div');\n\n  // Header transits to the next state when scrollY > 0 (upon scrolling from the top)\n  navigationMenu.classList.toggle('sticky', window.scrollY > 0);\n  menuHeaders.forEach((link) => {\n    link.classList.toggle('sticky', window.scrollY > 0);\n  });\n\n  navigationLinks.forEach((link) => {\n    let section = document.querySelector(link.hash);\n\n    if (section.offsetTop <= fromTop && section.offsetTop + section.offsetHeight > fromTop) {\n      link.classList.add('active');\n    } else {\n      link.classList.remove('active');\n    }\n  });\n});*/\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log)\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals(console.log);\n"],"sourceRoot":""}